import { IWriter } from "steroid-template-utils"

type Choice = {
    "options": { [key: string]: Arguments },
    dependencies: null | string[]
}

type Argument = {
    label: string,
    type:
    ["number"]
    |
    ["lookup", string[]]
    |
    ["newentry"]
    |
    ["string"]
    |
    ["file", {
        type: "readFile" | "string",
        ext: string
    }]
    |
    ["dir"]
    |
    ["choice", Choice]
    |
    ["array", Arguments]
}

type Arguments = Argument[]

type Commands = {
    [key: string]: {
        arguments: Arguments
    }
}

export type Contexts = {
    [key: string]: {
        commands: Commands
    }
}

function printArgumentsHelp(args: Arguments): string {
    return args.map(arg => {
        switch (arg.type[0]) {
            case "choice":
                const options = arg.type[1].options
                return `(${Object.keys(options).sort().map(optionName => `${optionName}:${printArgumentsHelp(options[optionName])}`).join(` | `)})`
            case "lookup":
                return `{${arg.label}}`
            case "newentry":
                return `{!${arg.label}}`
            case "string":
                return `$${arg.label}`
            case "number":
                return `#${arg.label}`
            case "dir":
                return `<${arg.label}>`
            case "file":
                return `<${arg.label}>`
            case "array":
                return `${arg.label}:[ ${printArgumentsHelp(arg.type[1])} ]`
        }
    }).join(` `)
}

function sanitize(str: string) {
    return str.replace(/\./g, `dot`)
}

function writeArgumentTypeDefinition(arg: Argument, choiceTypePrefix: string, writer: IWriter): void {
    switch (arg.type[0]) {
        case "file":
            switch (arg.type[1].type) {
                case "readFile":
                    writer.write(`IUnsafePromise<Buffer, string>`)

                    break
                case "string":
                    writer.write(`string`)

                    break
               default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[1].type)

            }
            break
        case "dir":
            writer.write(`string`)
            break
        case "lookup":
            writer.write(`string`)
            break
        case "newentry":
            writer.write(`string`)
            break
        case "choice":
            writer.write(choiceTypePrefix)
            break
        case "number":
            writer.write(`number`)
            break
        case "string":
            writer.write(`string`)
            break
        case "array":
            const arrayData = arg.type[1]
            writer.write(
                `Array<{`, () => {
                    writeArgumentsTypeDefinition(arrayData, choiceTypePrefix, writer)

                }, `}>`
            )
            break
       default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[0])
    }

}

function writeArgumentsTypeDefinition(args: Arguments, choiceTypePrefix: string, writer: IWriter): void {
    args.forEach(arg => {
        writer.snippet(`${arg.label}: `)
        writeArgumentTypeDefinition(arg, choiceTypePrefix + "_" + arg.label, writer)
    })
}

function writeArgumentParser(args: Arguments, index: number, path: string[], choiceTypePrefix: string, writer: IWriter): void {
    if (index === args.length) {
        return
    }
    const arg = args[index]
    function writeGetNext(variable: string, label: string) {
        writer.write(
            `const ${variable} = _tokens.getNext()`,
            `if (${variable} === null) {`, () => {
                writer.write(`return error("missing ${label} argument")`)
            }, "}",
        )
    }
    const tokenGetter = `raw_${arg.label}.value`
    switch (arg.type[0]) {
        case "file":
            writeGetNext(`raw_${arg.label}`, arg.label)
            switch (arg.type[1].type) {
                case "readFile":
                    writer.write(`const final_${arg.label} = _fs.getFileContentGetter(${tokenGetter})`)
                    break
                case "string":
                    writer.write(
                        `const final_${arg.label} = _fs.getSafePath(${tokenGetter})`,
                        `if (final_${arg.label} === null) {`, () => {
                            writer.write(`return error("invalid path: ${arg.label}")`)
                        }, "}"
                    )
                    break
               default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[1].type)

            }
            break
        case "lookup":
            writeGetNext(`raw_${arg.label}`, arg.label)
            writer.write(`const final_${arg.label} = ${tokenGetter}`)

            break
        case "choice":
            const options = arg.type[1].options
            const choiceData = arg.type[1]
            if (choiceData.dependencies === null) {
                //no dependencies
                writeGetNext(`raw_${arg.label}`, arg.label)

                writer.write(
                    `let interim_${arg.label}: undefined | ${choiceTypePrefix + "_" + arg.label}`,
                    `switch (${tokenGetter}) {`, () => {
                        Object.keys(options).sort().forEach(opt => {
                            writer.write(
                                `case "${opt}": {`, () => {
                                    writer.write(`interim_${arg.label} = [ "${opt}", (() => {`, () => {
                                        writeArgumentsParser(options[opt], path.concat([arg.label, opt]), choiceTypePrefix + "_" + arg.label + "_" + opt, writer)
                                        writer.write(
                                            `const val: {`, () => {
                                                writeArgumentsTypeDefinition(options[opt], choiceTypePrefix + "_" + arg.label + "_" + opt, writer)
                                            }, `} = {`, () => {
                                                writeArgumentsSetter(options[opt], writer)
                                            }, "}",
                                            "return val"
                                        )
                                    })
                                    writer.write(
                                        `})()]`,
                                        `break`
                                    )
                                }, `}`
                            )
                        })
                        writer.write(`default: {`)
                        writer.write(() => {
                            writer.write(`return error("invalid ${arg.label} argument")`)
                        })
                        writer.write(`}`)
                    }, `}`,
                    `const final_${arg.label} = interim_${arg.label}`,
                    `if (final_${arg.label} === undefined) { return error("foo")}`

                )
            } else {
                //there are dependencies
                const dependencies = choiceData.dependencies
                writer.write(
                    `const args_${arg.label} = {`, () => {
                        dependencies.forEach(dependency => {
                            writer.write(`${dependency}: raw_${dependency}.value,`)
                        })
                    }, "}",
                    `let final_${arg.label}: null | ${choiceTypePrefix}_${arg.label} = null`,
                    `${path.join(".")}.get_${arg.label}(args_${arg.label}).try<${choiceTypePrefix}_${arg.label}>(`, () => {
                        writer.write(
                            `state => {`, () => {
                                writer.write(
                                    `switch (state) {`, () => {
                                        Object.keys(choiceData.options).sort().forEach(option => {
                                            writer.write(
                                                `case "${option}": {`, () => {
                                                    writeArgumentsParser(options[option], path.concat([arg.label, option]), choiceTypePrefix + "_" + arg.label + "_" + option, writer)
                                                    writer.write(
                                                        `return [ "success", [ "${option}", {`, () => {
                                                            writeArgumentsSetter(options[option], writer)
                                                        }, `} ]]`
                                                    )
                                                }, `}`
                                            )
                                        })
                                        writer.write(`default: return [ "error", "unknown state"]`)
                                    }, `}`
                                )
                            }, `},`
                        )

                    }, `).handle(`, () => {
                        writer.write(
                            `fubar`
                        )
                    }, `)`,
                    `if (final_${arg.label} === null) {`, () => {
                        writer.write(`return error("invalid ${arg.label} argument **POSSIBLE ASYNC PROBLEM**")`)
                    }, `}`
                )
            }


            break
        case "string":
            writeGetNext(`raw_${arg.label}`, arg.label)
            writer.write(`const final_${arg.label} = ${tokenGetter}`)
            break
        case "dir":
            writeGetNext(`raw_${arg.label}`, arg.label)
            writer.write(`const final_${arg.label} = ${tokenGetter}`)
            break
        case "newentry":
            writeGetNext(`raw_${arg.label}`, arg.label)
            writer.write(`const final_${arg.label} = ${tokenGetter}`)
            break
        case "array":
            const arrayData = arg.type[1]
            writeGetNext("rawbegin_" + arg.label, arg.label + " begin ([)")
            writer.write(
                `if (rawbegin_${arg.label} !== "[") { console.error("missing ["); return null }`,
                `const finalx_${arg.label} = new Array<{`, () => {
                    writeArgumentsTypeDefinition(arrayData, choiceTypePrefix + "_" + arg.label, writer)

                }, `}>()`,
                `const begin_${arg.label} = _tokens.lookAhead()`,
                `while (begin_${arg.label} !== null && begin_${arg.label} !== "]") {`, () => {
                    writeArgumentsParser(arrayData, path.concat(["elements[foo]"]), choiceTypePrefix + "_" + arg.label, writer)
                    writer.write(`finalx_${arg.label}.push({`)
                    writer.write(() => {
                        writeArgumentsSetter(arrayData, writer)
                    })
                    writer.write(`})`)
                }, "}",
                `const final_${arg.label} = new StaticStream(finalx_${arg.label} )`,
            )
            writeGetNext("rawend_" + arg.label, arg.label + " end (])")
            writer.write(`if (rawend_${arg.label} !== "]") { console.error("missing ]"); return null }`)

            break
        case "number":
            writeGetNext(`raw_${arg.label}`, arg.label)
            writer.write(`const final_${arg.label} = ${path.join(".")}.convertToNumber_${arg.label}(${tokenGetter})`)
            writer.write(`if (final_${arg.label} === null) {`)
            writer.write(() => {
                writer.write(`return error("${arg.label} is not a number")`)
            })
            writer.write(`}`)

            break
       default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[0])

    }
    writeArgumentParser(args, index + 1, path, choiceTypePrefix, writer)
}

function writeArgumentsParser(args: Arguments, path: string[], choiceTypePrefix: string, writer: IWriter): void {
    writeArgumentParser(args, 0, path, choiceTypePrefix, writer)
}

function writeArgumentsSetter(args: Arguments, writer: IWriter): void {
    args.forEach(arg => {
        writer.write(`${arg.label}: final_${arg.label},`)
    })
}

function writeArgumentsHandlerInterface(args: Arguments, writer: IWriter): void {
    args.forEach(arg => {
        switch (arg.type[0]) {
            case "dir":
                return
            case "file":
                return
            case "lookup":
                writer.write(`getOptions_${arg.label}: (str: string, args: { ${arg.type[1].map(dependency => `"${dependency}": string`).join(", ")} }) => AutocompleteOptionsPromise`)
                return
            case "choice":
                const choiceData = arg.type[1]
                if (choiceData.dependencies !== null) {
                    writer.write(`get_${arg.label}: (args: { ${choiceData.dependencies.map(dependency => `"${dependency}": string`).join(", ")} }) => IUnsafePromise<${Object.keys(choiceData.options).sort().map(opt => `"${opt}"`).join(" | ")}, string>`)

                }
                writer.write(`${arg.label}: {`)
                writer.write(() => {
                    const options = choiceData.options
                    Object.keys(options).sort().forEach(opt => {
                        writer.write(`${opt}: {`)
                        writer.write(() => {
                            writeArgumentsHandlerInterface(options[opt], writer)
                        })
                        writer.write(`}`)
                    })
                })
                writer.write(`}`)
                return
            case "number":
                writer.write(`convertToNumber_${arg.label}: (str: string) => number | null`)

                return
            case "string":
                return
            case "newentry":
                return
            case "array":
                const arrayData = arg.type[1]
                writer.write(`${arg.label}: {`)
                writer.write(() => {
                    writeArgumentsHandlerInterface(arrayData, writer)
                })
                writer.write(`}`)
                return
           default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[0])

        }
    })


}

function writeArgumentsAutoCorrectBuilder(args: Arguments, path: string[], writer: IWriter): void {

    function writeGetNext(variable: string, noMoreTokens: () => void, moreTokens: () => void) {
        writer.write(`const ${variable} = _tokens.getNext()`)
        writer.write(`if (${variable} === null) {`)
        writer.write(() => {
            writer.write(`return error("no tokens")`)
        })
        writer.write(`}`)

        writer.write(`if (!_tokens.hasMore()) { //last argument, build options for this one`)
        writer.write(() => {
            noMoreTokens()
        })
        writer.write(`} else {`)
        writer.write(() => {
            moreTokens()
        })
        writer.write(`}`)
    }


    args.forEach(arg => {
        const tokenGetter = `raw_${arg.label}.value`
        switch (arg.type[0]) {
            case "file":
                const fileData = arg.type[1]
                writeGetNext(`raw_${arg.label}`,
                    () => {
                        writer.write(
                            `if (raw_${arg.label}.stringLiteral[0] && raw_${arg.label}.stringLiteral[1].isEnded) { return error("requires exact match") }`,
                            `return _fs.getFileOptions(${tokenGetter}, "${fileData.ext}")`
                        )
                    },
                    () => {
                    }
                )
                break
            case "dir":
                writeGetNext(`raw_${arg.label}`,
                    () => {
                        writer.write(
                            `if (raw_${arg.label}.stringLiteral[0] && raw_${arg.label}.stringLiteral[1].isEnded) { return error("requires exact match") }`,
                            `return _fs.getFileOptions(${tokenGetter}, null, raw_${arg.label}.stringLiteral[0] && raw_${arg.label}.stringLiteral[1].isEnded))`
                        )
                    },
                    () => {
                    }
                )
                break
            case "lookup": {
                const dependencies = arg.type[1]
                writeGetNext(`raw_${arg.label}`,
                    () => {
                        writer.write(
                            `const args_${arg.label} = {`, () => {
                                dependencies.forEach(dependency => {
                                    writer.write(`${dependency}: raw_${dependency}.value,`)
                                })
                            }, "}",
                            `if (raw_${arg.label}.stringLiteral[0] && raw_${arg.label}.stringLiteral[1].isEnded) { return error("requires exact match") }`,
                            `return ${path.join(".")}.getOptions_${arg.label}(${tokenGetter}, args_${arg.label}).mapResultRaw(options => ({ options: options, originalString: ${tokenGetter}}))`
                        )
                    },
                    () => {
                    }
                )

                break
            }
            case "choice":
                const choiceData = arg.type[1]
                const options = arg.type[1].options
                if (choiceData.dependencies !== null) {
                    const dependencies = choiceData.dependencies
                    writer.write(`const args_${arg.label} = {`)
                    writer.write(() => {
                        dependencies.forEach(dependency => {
                            writer.write(`${dependency}: raw_${dependency}.value,`)
                        })
                    })

                    writer.write("}")
                    writer.write(`${path.join(".")}.get_${arg.label}(args_${arg.label}).handle(`)
                    writer.write(() => {
                        writer.write(`() => {`)
                        writer.write(() => {

                        })
                        writer.write(`},`)
                        writer.write(`state => {`)
                        writer.write(() => {
                            writer.write(`switch (state) {`)
                            writer.write(() => {
                                Object.keys(choiceData.options).sort().forEach(option => {
                                    writer.write(`case "${option}": {`)
                                    writer.write(() => {
                                        writeArgumentsAutoCorrectBuilder(options[option], path.concat([arg.label, option]), writer)
                                    })
                                    writer.write(`}`)
                                })
                                writer.write(`default: return "XXX"`)
                            })
                            writer.write(`}`)
                        })
                        writer.write(`},`)
                    })
                    writer.write(`)`)
                } else {
                    writeGetNext(`raw_${arg.label}`,
                        () => {
                            writer.write(`return success({ options: new StaticStream([${Object.keys(options).sort().map(opt => `"${opt}"`).join(`, `)}].filter(c => c.startsWith(${tokenGetter}))), originalString: ${tokenGetter}})`)
                        },
                        () => {
                            writer.write(`const ${arg.label}: { [key: string]: () => void } = {`)
                            writer.write(() => {
                                Object.keys(options).sort().forEach(opt => {
                                    writer.write(`${opt}: () => {`)
                                    writer.write(() => {
                                        writeArgumentsAutoCorrectBuilder(options[opt], path.concat([arg.label, opt]), writer)
                                    })
                                    writer.write(`},`)
                                })
                            })
                            writer.write(`}`)
                            writer.write(`if (${arg.label}[${tokenGetter}] === undefined) {`)
                            writer.write(() => {
                                writer.write(`console.error("invalid option: " + ${tokenGetter})`)
                                writer.write(
                                    `return success({ options: new StaticStream([${Object.keys(options).sort().map(opt => `"${opt}"`).join(`, `)}]), originalString: ${tokenGetter} })`
                                )
                            })
                            writer.write(`} else {`)
                            writer.write(() => {
                                writer.write(`${arg.label}[${tokenGetter}]()`)
                            })
                            writer.write("}")
                        }
                    )
                }
                break
            case "newentry":
                writeGetNext(`raw_${arg.label}`,
                    () => {
                        //writer.write(`console.error("${arg.label}")`)
                        writer.write(`return success({ options: new EmptyStream<string>(), originalString: ""})`)
                    },
                    () => {
                    }
                )
                break
            case "string":
                writeGetNext(`raw_${arg.label}`,
                    () => {
                        //writer.write(`console.error("${arg.label}")`)

                        writer.write(`return success({ options: new EmptyStream<string>(), originalString: ""})`)
                    },
                    () => {
                    }
                )
                break
            case "array":
                const arrayData = arg.type[1]
                writeGetNext("rawbegin_" + arg.label,
                    () => {
                        //writer.write(`console.error("${arg.label}")`)

                        writer.write(`return success({ options: new StaticStream([ "[" ]), originalString: ""})`)
                    },
                    () => {
                    }
                )
                writer.write(
                    `const end_${arg.label} = _tokens.lookAhead()`,
                    `while (end_${arg.label} !== null && end_${arg.label} !== "]") {`
                )
                writer.write(() => {
                    writeArgumentsAutoCorrectBuilder(arrayData, path.concat(["foo"]), writer)
                })
                writer.write("}")
                writeGetNext("rawend_" + arg.label,
                    () => {
                        //writer.write(`console.error("${arg.label}")`)

                        writer.write(`return success({ options: new StaticStream([ "]" ]), originalString: ""})`)
                    },
                    () => {
                    }
                )
                break
            case "number":
                writeGetNext(`raw_${arg.label}`,
                    () => {
                        //writer.write(`console.error("${arg.label}")`)

                        writer.write(`return success({ options: new EmptyStream(), originalString: ""})`)
                    },
                    () => {
                    }
                )
                break
           default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[0])

        }

    })
    writer.write(`return error("end of arguments to parse")`)
}

function writeChoiceTypeDefinitions(args: Arguments, choiceTypePrefix: string, writer: IWriter) {
    args.forEach(arg => {
        switch (arg.type[0]) {
            case "dir":
                return
            case "file":
                return
            case "lookup":
                return
            case "choice":
                const choiceData = arg.type[1]
                const options = choiceData.options
                const newPrefix = choiceTypePrefix + "_" + arg.label
                writer.write(
                    `type ${newPrefix} = `, () => {
                        let first = true
                        Object.keys(options).sort().forEach(option => {
                            if (!first) {
                                writer.write(`|`)
                            }
                            writer.write(
                                `[ "${option}", {`, () => {
                                    writeArgumentsTypeDefinition(options[option], choiceTypePrefix + "_" + arg.label + "_" + option, writer)
                                }, `}]`
                            )
                            first = false
                        })
                    }
                )
                Object.keys(options).sort().forEach(opt => {
                    writeChoiceTypeDefinitions(options[opt], newPrefix + "_" + opt, writer)
                })
                return
            case "number":
                return
            case "string":
                return
            case "newentry":
                return
            case "array":
                writeChoiceTypeDefinitions(arg.type[1], choiceTypePrefix + "_" + arg.label, writer)
                return
           default: ((_x: never): never => { throw new Error("Didn't expect to get here") })(arg.type[0])

        }
    })
}

export function generate(contexts: Contexts, writer: IWriter) {
    writer.write(
        `/* tslint:disable: variable-name no-empty max-line-length no-namespace object-literal-sort-keys */`,
        `import { create, EmptyStream, error, IInStream, ISafePromise, success, IUnsafePromise } from "pareto"`,
        `import { StaticStream } from "pareto-20"`,
        ``,
        `type Token = {`, () => {
            writer.write(
                `value: string,`,
                `stringLiteral: [false] | [true, {  isEnded: boolean }]`
            )
        }, `}`,
        `export type Tokens = { getNext: () => Token | null, lookAhead: () => Token | null, hasMore: () => boolean }`,
        `export type FileSystem = {`, () => {
            writer.write(
                `getFileContentGetter: (argName: string) => IUnsafePromise<Buffer, string>,`,
                `getSafePath: (argName: string) => string | null,`,
                `getFileOptions: (str: string, ext: string | null) => AutocompletePromise`
            )
        }, `}`,
        `export type AutocompleteCallback = (options: AutocompleteData) => void`,
        `export type ReadlineInterface = {`, () => {
            writer.write(
                `question: (prompt: string, autoCompleter: (line: string) => ISafePromise<IInStream<string>>) => ISafePromise<string>`,
                `log: (text: string) => void`
            )
        }, `}`,
        `export type AutocompleteData = {`, () => {
            writer.write(
                `options: IInStream<string>`,
                `originalString: string`
            )

        }, `}`,
        `export type AutocompleteOptions = IInStream<string>`,
        `type AutocompletePromise = IUnsafePromise<AutocompleteData, string>`,
        `type AutocompleteOptionsPromise = IUnsafePromise<AutocompleteOptions, string>`,
        `export type PromptSettings = {`, () => {
            writer.write(
                `prompt: string,`,
                `autoCompleter: (fs: FileSystem, tokens: Tokens) => IUnsafePromise<AutocompleteData, string>`,
                `handler: (fs: FileSystem, readlineInterface: ReadlineInterface, input: Tokens) => ISafePromise<HandleResult>`
            )
        }, `}`,
        `export type HandleResult = [ "current" ] | [ "new", PromptSettings] | [ "parent" ]`,
        `export type HandleResultPromise = ISafePromise<HandleResult>`
    )

    Object.keys(contexts).sort().forEach(contextName => {
        const context = contexts[contextName]
        writer.write(``)
        writer.write(`export namespace ${contextName} {`)
        writer.write(() => {
            Object.keys(context.commands).sort().forEach(commandName => {
                const command = context.commands[commandName]

                writeChoiceTypeDefinitions(command.arguments, "OptionArg_" + sanitize(commandName), writer)

                writer.write(``)
                writer.write(`type Arg_${sanitize(commandName)} = {`)
                writer.write(() => {
                    writeArgumentsTypeDefinition(command.arguments, "OptionArg_" + sanitize(commandName), writer)
                })
                writer.write(`}`)

                writer.write(
                    ``,
                    `function parseArguments_${sanitize(commandName)}(_tokens: Tokens, _fs: FileSystem, _handler: Handler_${sanitize(commandName)}): IUnsafePromise<Arg_${sanitize(commandName)}, string> {`, () => {

                        writeArgumentsParser(command.arguments, ["_handler.argumentsHandler"], "OptionArg_" + sanitize(commandName), writer)
                        writer.write(`return success({`)
                        writer.write(() => {
                            writeArgumentsSetter(command.arguments, writer)
                        })
                        writer.write(`})`)


                    }, `}`
                )

                writer.write(
                    ``,
                    `function handle_${sanitize(commandName)}(tokens: Tokens, fs: FileSystem, readlineInterface: ReadlineInterface, _onError: (message: string) => HandleResultPromise, handler: Handler_${sanitize(commandName)}): HandleResultPromise {`, () => {

                        writer.write(
                            `return create.Promise.safe.from.UnsafePromise(parseArguments_${sanitize(commandName)}(tokens, fs, handler)).rework(`, () => {
                                writer.write(
                                    `error => _onError(error),`,
                                    `args => handler.handle(args, readlineInterface)`
                                )
                            }, `)`
                        )
                    }, `}`
                )

                writer.write(``)
                writer.write(`type ArgumentsHandler_${sanitize(commandName)} = {`)
                writer.write(() => {
                    writeArgumentsHandlerInterface(command.arguments, writer)

                })
                writer.write(`}`)

                writer.write(``)
                writer.write(`type Handler_${sanitize(commandName)} = {`)
                writer.write(() => {
                    writer.write(`argumentsHandler: ArgumentsHandler_${sanitize(commandName)} `)
                    writer.write(`handle: (args: Arg_${sanitize(commandName)}, readlineInterface: ReadlineInterface) => HandleResultPromise`)
                })
                writer.write(`}`)


                writer.write(``)
                writer.write(`function buildAutocompleteData_${sanitize(commandName)}(_tokens: Tokens, _fs: FileSystem, _handler: ArgumentsHandler_${sanitize(commandName)}): AutocompletePromise {`)
                writer.write(() => {

                    writeArgumentsAutoCorrectBuilder(command.arguments, ["_handler"], writer)
                })
                writer.write(`}`)


            })
            writer.write(``)
            writer.write(`export type Handlers = {`)
            writer.write(() => {
                writer.write(`handleUnknownCommand: () => HandleResultPromise`)
                writer.write(`onError: (message: string) => HandleResultPromise`)
                writer.write(`commands: {`)
                writer.write(() => {

                    Object.keys(context.commands).sort().forEach(commandName => {
                        writer.write(`${sanitize(commandName)}: Handler_${sanitize(commandName)} `)
                    })
                })
                writer.write(`}`)

            })
            writer.write(`}`)

            writer.write(``)
            writer.write(`export function handle(tokens: Tokens, fs: FileSystem, readlineInterface: ReadlineInterface, handlers: Handlers): HandleResultPromise {`)
            writer.write(() => {
                writer.write(`const token_commandname = tokens.getNext()`)
                writer.write(`if (token_commandname === null) {`)
                writer.write(() => {
                    writer.write(`return handlers.onError("missing command")`)
                })
                writer.write(`}`)
                writer.write(`const commandname = token_commandname.value`)
                writer.write(`switch (commandname) {`)
                writer.write(() => {
                    Object.keys(context.commands).sort().forEach(commandName => {
                        writer.write(`case "${commandName}": {`)
                        writer.write(() => {
                            writer.write(`return handle_${sanitize(commandName)}(tokens, fs, readlineInterface, handlers.onError, handlers.commands.${sanitize(commandName)})`)
                            writer.write(`break`)
                        })
                        writer.write(`}`)
                    })
                    writer.write(`default: return handlers.handleUnknownCommand()`)
                })
                writer.write(`}`)

            })
            writer.write(`}`)

            writer.write(
                ``,
                `export function buildAutocomplete(tokens: Tokens, fs: FileSystem, handlers: Handlers): AutocompletePromise {`, () => {
                    writer.write(
                        `const token_commandname = tokens.getNext()`,
                        `if (token_commandname === null) {`, () => {
                            writer.write(`return error("missing command token")`)
                        }, `}`,
                        `const commandname = token_commandname.value`,
                        `if (tokens.hasMore()) {`, () => {
                            writer.write(`switch (commandname) {`)
                            writer.write(() => {
                                Object.keys(context.commands).sort().forEach(commandName => {
                                    writer.write(`case "${commandName}": {`)
                                    writer.write(() => {
                                        writer.write(`return buildAutocompleteData_${sanitize(commandName)} (tokens, fs, handlers.commands.${sanitize(commandName)}.argumentsHandler)`)
                                    })
                                    writer.write(`}`)
                                })
                                writer.write(`default: return error("unknown command")`)

                            }, `}`)
                        },
                        `} else { //no more arguments, built autocomplete options`, () => {
                            writer.write(`return success({ options: new StaticStream([${Object.keys(context.commands).sort().map(cmd => `"${cmd}"`).join(`, `)}].filter(c => c.startsWith(commandname))), originalString: commandname })`)
                        }, `}`
                    )
                }, `}`
            )

            writer.write(``)
            writer.write(`export function printHelp() {`)
            writer.write(() => {
                writer.write(`return [`)

                Object.keys(context.commands).sort().forEach(commandName => {
                    writer.write(`"${commandName} ${printArgumentsHelp(context.commands[commandName].arguments)}",`)
                })
                writer.write(`]`)
            })
            writer.write(`}`)
        })


        writer.write(`}`)
    })
    writer.write(``)

}
