import * as ts from "typescript"

export type GeneratedTypedNode =
    // | [ "Unknown", ts.Unknown ]
    | ["EndOfFileToken", ts.EndOfFileToken]
    // | [ "SingleLineCommentTrivia", ts.SingleLineCommentTrivia ]
    // | [ "MultiLineCommentTrivia", ts.MultiLineCommentTrivia ]
    // | [ "NewLineTrivia", ts.NewLineTrivia ]
    // | [ "WhitespaceTrivia", ts.WhitespaceTrivia ]
    // | [ "ShebangTrivia", ts.ShebangTrivia ]
    // | [ "ConflictMarkerTrivia", ts.ConflictMarkerTrivia ]
    | ["NumericLiteral", ts.NumericLiteral]
    | ["BigIntLiteral", ts.BigIntLiteral]
    | ["StringLiteral", ts.StringLiteral]
    | ["JsxText", ts.JsxText]
    // | [ "JsxTextAllWhiteSpaces", ts.JsxTextAllWhiteSpaces ]
    | ["RegularExpressionLiteral", ts.RegularExpressionLiteral]
    | ["NoSubstitutionTemplateLiteral", ts.NoSubstitutionTemplateLiteral]
    | ["TemplateHead", ts.TemplateHead]
    | ["TemplateMiddle", ts.TemplateMiddle]
    | ["TemplateTail", ts.TemplateTail]
    // | [ "OpenBraceToken", ts.OpenBraceToken ]
    // | [ "CloseBraceToken", ts.CloseBraceToken ]
    // | [ "OpenParenToken", ts.OpenParenToken ]
    // | [ "CloseParenToken", ts.CloseParenToken ]
    // | [ "OpenBracketToken", ts.OpenBracketToken ]
    // | [ "CloseBracketToken", ts.CloseBracketToken ]
    // | [ "DotToken", ts.DotToken ]
    | ["DotDotDotToken", ts.DotDotDotToken]
    // | [ "SemicolonToken", ts.SemicolonToken ]
    // | [ "CommaToken", ts.CommaToken ]
    // | [ "LessThanToken", ts.LessThanToken ]
    // | [ "LessThanSlashToken", ts.LessThanSlashToken ]
    // | [ "GreaterThanToken", ts.GreaterThanToken ]
    // | [ "LessThanEqualsToken", ts.LessThanEqualsToken ]
    // | [ "GreaterThanEqualsToken", ts.GreaterThanEqualsToken ]
    // | [ "EqualsEqualsToken", ts.EqualsEqualsToken ]
    // | [ "ExclamationEqualsToken", ts.ExclamationEqualsToken ]
    // | [ "EqualsEqualsEqualsToken", ts.EqualsEqualsEqualsToken ]
    // | [ "ExclamationEqualsEqualsToken", ts.ExclamationEqualsEqualsToken ]
    | ["EqualsGreaterThanToken", ts.EqualsGreaterThanToken]
    | ["PlusToken", ts.PlusToken]
    | ["MinusToken", ts.MinusToken]
    | ["AsteriskToken", ts.AsteriskToken]
    // | [ "AsteriskAsteriskToken", ts.AsteriskAsteriskToken ]
    // | [ "SlashToken", ts.SlashToken ]
    // | [ "PercentToken", ts.PercentToken ]
    // | [ "PlusPlusToken", ts.PlusPlusToken ]
    // | [ "MinusMinusToken", ts.MinusMinusToken ]
    // | [ "LessThanLessThanToken", ts.LessThanLessThanToken ]
    // | [ "GreaterThanGreaterThanToken", ts.GreaterThanGreaterThanToken ]
    // | [ "GreaterThanGreaterThanGreaterThanToken", ts.GreaterThanGreaterThanGreaterThanToken ]
    // | [ "AmpersandToken", ts.AmpersandToken ]
    // | [ "BarToken", ts.BarToken ]
    // | [ "CaretToken", ts.CaretToken ]
    | ["ExclamationToken", ts.ExclamationToken]
    // | [ "TildeToken", ts.TildeToken ]
    // | [ "AmpersandAmpersandToken", ts.AmpersandAmpersandToken ]
    // | [ "BarBarToken", ts.BarBarToken ]
    | ["QuestionToken", ts.QuestionToken]
    | ["ColonToken", ts.ColonToken]
    // | [ "AtToken", ts.AtToken ]
    /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
    // | [ "BacktickToken", ts.BacktickToken ]
    | ["EqualsToken", ts.EqualsToken]
    // | [ "PlusEqualsToken", ts.PlusEqualsToken ]
    // | [ "MinusEqualsToken", ts.MinusEqualsToken ]
    // | [ "AsteriskEqualsToken", ts.AsteriskEqualsToken ]
    // | [ "AsteriskAsteriskEqualsToken", ts.AsteriskAsteriskEqualsToken ]
    // | [ "SlashEqualsToken", ts.SlashEqualsToken ]
    // | [ "PercentEqualsToken", ts.PercentEqualsToken ]
    // | [ "LessThanLessThanEqualsToken", ts.LessThanLessThanEqualsToken ]
    // | [ "GreaterThanGreaterThanEqualsToken", ts.GreaterThanGreaterThanEqualsToken ]
    // | [ "GreaterThanGreaterThanGreaterThanEqualsToken", ts.GreaterThanGreaterThanGreaterThanEqualsToken ]
    // | [ "AmpersandEqualsToken", ts.AmpersandEqualsToken ]
    // | [ "BarEqualsToken", ts.BarEqualsToken ]
    // | [ "CaretEqualsToken", ts.CaretEqualsToken ]
    | ["Identifier", ts.Identifier]
    // | [ "BreakKeyword", ts.BreakKeyword ]
    // | [ "CaseKeyword", ts.CaseKeyword ]
    // | [ "CatchKeyword", ts.CatchKeyword ]
    // | [ "ClassKeyword", ts.ClassKeyword ]
    // | [ "ConstKeyword", ts.ConstKeyword ]
    // | [ "ContinueKeyword", ts.ContinueKeyword ]
    // | [ "DebuggerKeyword", ts.DebuggerKeyword ]
    // | [ "DefaultKeyword", ts.DefaultKeyword ]
    // | [ "DeleteKeyword", ts.DeleteKeyword ]
    // | [ "DoKeyword", ts.DoKeyword ]
    // | [ "ElseKeyword", ts.ElseKeyword ]
    // | [ "EnumKeyword", ts.EnumKeyword ]
    // | [ "ExportKeyword", ts.ExportKeyword ]
    // | [ "ExtendsKeyword", ts.ExtendsKeyword ]
    // | [ "FalseKeyword", ts.FalseKeyword ]
    // | [ "FinallyKeyword", ts.FinallyKeyword ]
    // | [ "ForKeyword", ts.ForKeyword ]
    // | [ "FunctionKeyword", ts.FunctionKeyword ]
    // | [ "IfKeyword", ts.IfKeyword ]
    // | [ "ImportKeyword", ts.ImportKeyword ]
    // | [ "InKeyword", ts.InKeyword ]
    // | [ "InstanceOfKeyword", ts.InstanceOfKeyword ]
    // | [ "NewKeyword", ts.NewKeyword ]
    // | [ "NullKeyword", ts.NullKeyword ]
    // | [ "ReturnKeyword", ts.ReturnKeyword ]
    // | [ "SuperKeyword", ts.SuperKeyword ]
    // | [ "SwitchKeyword", ts.SwitchKeyword ]
    // | [ "ThisKeyword", ts.ThisKeyword ]
    // | [ "ThrowKeyword", ts.ThrowKeyword ]
    // | [ "TrueKeyword", ts.TrueKeyword ]
    // | [ "TryKeyword", ts.TryKeyword ]
    // | [ "TypeOfKeyword", ts.TypeOfKeyword ]
    // | [ "VarKeyword", ts.VarKeyword ]
    // | [ "VoidKeyword", ts.VoidKeyword ]
    // | [ "WhileKeyword", ts.WhileKeyword ]
    // | [ "WithKeyword", ts.WithKeyword ]
    // | [ "ImplementsKeyword", ts.ImplementsKeyword ]
    // | [ "InterfaceKeyword", ts.InterfaceKeyword ]
    // | [ "LetKeyword", ts.LetKeyword ]
    // | [ "PackageKeyword", ts.PackageKeyword ]
    // | [ "PrivateKeyword", ts.PrivateKeyword ]
    // | [ "ProtectedKeyword", ts.ProtectedKeyword ]
    // | [ "PublicKeyword", ts.PublicKeyword ]
    // | [ "StaticKeyword", ts.StaticKeyword ]
    // | [ "YieldKeyword", ts.YieldKeyword ]
    // | [ "AbstractKeyword", ts.AbstractKeyword ]
    // | [ "AsKeyword", ts.AsKeyword ]
    // | [ "AnyKeyword", ts.AnyKeyword ]
    // | [ "AsyncKeyword", ts.AsyncKeyword ]
    // | [ "AwaitKeyword", ts.AwaitKeyword ]
    // | [ "BooleanKeyword", ts.BooleanKeyword ]
    // | [ "ConstructorKeyword", ts.ConstructorKeyword ]
    // | [ "DeclareKeyword", ts.DeclareKeyword ]
    // | [ "GetKeyword", ts.GetKeyword ]
    // | [ "InferKeyword", ts.InferKeyword ]
    // | [ "IsKeyword", ts.IsKeyword ]
    // | [ "KeyOfKeyword", ts.KeyOfKeyword ]
    // | [ "ModuleKeyword", ts.ModuleKeyword ]
    // | [ "NamespaceKeyword", ts.NamespaceKeyword ]
    // | [ "NeverKeyword", ts.NeverKeyword ]
    // | [ "ReadonlyKeyword", ts.ReadonlyKeyword ]
    // | [ "RequireKeyword", ts.RequireKeyword ]
    // | [ "NumberKeyword", ts.NumberKeyword ]
    // | [ "ObjectKeyword", ts.ObjectKeyword ]
    // | [ "SetKeyword", ts.SetKeyword ]
    // | [ "StringKeyword", ts.StringKeyword ]
    // | [ "SymbolKeyword", ts.SymbolKeyword ]
    // | [ "TypeKeyword", ts.TypeKeyword ]
    // | [ "UndefinedKeyword", ts.UndefinedKeyword ]
    // | [ "UniqueKeyword", ts.UniqueKeyword ]
    // | [ "UnknownKeyword", ts.UnknownKeyword ]
    // | [ "FromKeyword", ts.FromKeyword ]
    // | [ "GlobalKeyword", ts.GlobalKeyword ]
    // | [ "BigIntKeyword", ts.BigIntKeyword ]
    // | [ "OfKeyword", ts.OfKeyword ]
    | ["QualifiedName", ts.QualifiedName]
    | ["ComputedPropertyName", ts.ComputedPropertyName]
    //| ["TypeParameter", ts.TypeParameter]
    // | [ "Parameter", ts.Parameter ]
    | ["Decorator", ts.Decorator]
    | ["PropertySignature", ts.PropertySignature]
    | ["PropertyDeclaration", ts.PropertyDeclaration]
    | ["MethodSignature", ts.MethodSignature]
    | ["MethodDeclaration", ts.MethodDeclaration]
    // | [ "Constructor", ts.Constructor ]
    // | [ "GetAccessor", ts.GetAccessor ]
    // | [ "SetAccessor", ts.SetAccessor ]
    // | [ "CallSignature", ts.CallSignature ]
    // | [ "ConstructSignature", ts.ConstructSignature ]
    // | [ "IndexSignature", ts.IndexSignature ]
    // | ["TypePredicate", ts.TypePredicate]
    // | ["TypeReference", ts.TypeReference]
    // | [ "FunctionType", ts.FunctionType ]
    // | [ "ConstructorType", ts.ConstructorType ]
    // | [ "TypeQuery", ts.TypeQuery ]
    // | [ "TypeLiteral", ts.TypeLiteral ]
    // | [ "ArrayType", ts.ArrayType ]
    // | ["TupleType", ts.TupleType]
    // | [ "OptionalType", ts.OptionalType ]
    // | [ "RestType", ts.RestType ]
    // | ["UnionType", ts.UnionType]
    // | ["IntersectionType", ts.IntersectionType]
    // | ["ConditionalType", ts.ConditionalType]
    // | [ "InferType", ts.InferType ]
    // | [ "ParenthesizedType", ts.ParenthesizedType ]
    // | [ "ThisType", ts.ThisType ]
    // | [ "TypeOperator", ts.TypeOperator ]
    // | ["IndexedAccessType", ts.IndexedAccessType]
    // | [ "MappedType", ts.MappedType ]
    // | ["LiteralType", ts.LiteralType]
    // | [ "ImportType", ts.ImportType ]
    | ["ObjectBindingPattern", ts.ObjectBindingPattern]
    | ["ArrayBindingPattern", ts.ArrayBindingPattern]
    | ["BindingElement", ts.BindingElement]
    | ["ArrayLiteralExpression", ts.ArrayLiteralExpression]
    | ["ObjectLiteralExpression", ts.ObjectLiteralExpression]
    | ["PropertyAccessExpression", ts.PropertyAccessExpression]
    | ["ElementAccessExpression", ts.ElementAccessExpression]
    | ["CallExpression", ts.CallExpression]
    | ["NewExpression", ts.NewExpression]
    | ["TaggedTemplateExpression", ts.TaggedTemplateExpression]
    // | [ "TypeAssertionExpression", ts.TypeAssertionExpression ]
    | ["ParenthesizedExpression", ts.ParenthesizedExpression]
    | ["FunctionExpression", ts.FunctionExpression]
    | ["ArrowFunction", ts.ArrowFunction]
    | ["DeleteExpression", ts.DeleteExpression]
    | ["TypeOfExpression", ts.TypeOfExpression]
    | ["VoidExpression", ts.VoidExpression]
    | ["AwaitExpression", ts.AwaitExpression]
    | ["PrefixUnaryExpression", ts.PrefixUnaryExpression]
    | ["PostfixUnaryExpression", ts.PostfixUnaryExpression]
    | ["BinaryExpression", ts.BinaryExpression]
    | ["ConditionalExpression", ts.ConditionalExpression]
    | ["TemplateExpression", ts.TemplateExpression]
    | ["YieldExpression", ts.YieldExpression]
    | ["SpreadElement", ts.SpreadElement]
    | ["ClassExpression", ts.ClassExpression]
    | ["OmittedExpression", ts.OmittedExpression]
    | ["ExpressionWithTypeArguments", ts.ExpressionWithTypeArguments]
    | ["AsExpression", ts.AsExpression]
    | ["NonNullExpression", ts.NonNullExpression]
    | ["MetaProperty", ts.MetaProperty]
    | ["SyntheticExpression", ts.SyntheticExpression]
    | ["TemplateSpan", ts.TemplateSpan]
    | ["SemicolonClassElement", ts.SemicolonClassElement]
    | ["Block", ts.Block]
    | ["VariableStatement", ts.VariableStatement]
    | ["EmptyStatement", ts.EmptyStatement]
    | ["ExpressionStatement", ts.ExpressionStatement]
    | ["IfStatement", ts.IfStatement]
    | ["DoStatement", ts.DoStatement]
    | ["WhileStatement", ts.WhileStatement]
    | ["ForStatement", ts.ForStatement]
    | ["ForInStatement", ts.ForInStatement]
    | ["ForOfStatement", ts.ForOfStatement]
    | ["ContinueStatement", ts.ContinueStatement]
    | ["BreakStatement", ts.BreakStatement]
    | ["ReturnStatement", ts.ReturnStatement]
    | ["WithStatement", ts.WithStatement]
    | ["SwitchStatement", ts.SwitchStatement]
    | ["LabeledStatement", ts.LabeledStatement]
    | ["ThrowStatement", ts.ThrowStatement]
    | ["TryStatement", ts.TryStatement]
    | ["DebuggerStatement", ts.DebuggerStatement]
    | ["VariableDeclaration", ts.VariableDeclaration]
    | ["VariableDeclarationList", ts.VariableDeclarationList]
    | ["FunctionDeclaration", ts.FunctionDeclaration]
    | ["ClassDeclaration", ts.ClassDeclaration]
    | ["InterfaceDeclaration", ts.InterfaceDeclaration]
    | ["TypeAliasDeclaration", ts.TypeAliasDeclaration]
    | ["EnumDeclaration", ts.EnumDeclaration]
    | ["ModuleDeclaration", ts.ModuleDeclaration]
    | ["ModuleBlock", ts.ModuleBlock]
    | ["CaseBlock", ts.CaseBlock]
    | ["NamespaceExportDeclaration", ts.NamespaceExportDeclaration]
    | ["ImportEqualsDeclaration", ts.ImportEqualsDeclaration]
    | ["ImportDeclaration", ts.ImportDeclaration]
    | ["ImportClause", ts.ImportClause]
    | ["NamespaceImport", ts.NamespaceImport]
    | ["NamedImports", ts.NamedImports]
    | ["ImportSpecifier", ts.ImportSpecifier]
    | ["ExportAssignment", ts.ExportAssignment]
    | ["ExportDeclaration", ts.ExportDeclaration]
    | ["NamedExports", ts.NamedExports]
    | ["ExportSpecifier", ts.ExportSpecifier]
    | ["MissingDeclaration", ts.MissingDeclaration]
    | ["ExternalModuleReference", ts.ExternalModuleReference]
    | ["JsxElement", ts.JsxElement]
    | ["JsxSelfClosingElement", ts.JsxSelfClosingElement]
    | ["JsxOpeningElement", ts.JsxOpeningElement]
    | ["JsxClosingElement", ts.JsxClosingElement]
    | ["JsxFragment", ts.JsxFragment]
    | ["JsxOpeningFragment", ts.JsxOpeningFragment]
    | ["JsxClosingFragment", ts.JsxClosingFragment]
    | ["JsxAttribute", ts.JsxAttribute]
    | ["JsxAttributes", ts.JsxAttributes]
    | ["JsxSpreadAttribute", ts.JsxSpreadAttribute]
    | ["JsxExpression", ts.JsxExpression]
    | ["CaseClause", ts.CaseClause]
    | ["DefaultClause", ts.DefaultClause]
    | ["HeritageClause", ts.HeritageClause]
    | ["CatchClause", ts.CatchClause]
    | ["PropertyAssignment", ts.PropertyAssignment]
    | ["ShorthandPropertyAssignment", ts.ShorthandPropertyAssignment]
    | ["SpreadAssignment", ts.SpreadAssignment]
    | ["EnumMember", ts.EnumMember]
    | ["UnparsedPrologue", ts.UnparsedPrologue]
    | ["UnparsedPrepend", ts.UnparsedPrepend]
    // | [ "UnparsedText", ts.UnparsedText ]
    // | [ "UnparsedInternalText", ts.UnparsedInternalText ]
    | ["UnparsedSyntheticReference", ts.UnparsedSyntheticReference]
    | ["SourceFile", ts.SourceFile]
    | ["Bundle", ts.Bundle]
    | ["UnparsedSource", ts.UnparsedSource]
    | ["InputFiles", ts.InputFiles]
    | ["JSDocTypeExpression", ts.JSDocTypeExpression]
    | ["JSDocAllType", ts.JSDocAllType]
    | ["JSDocUnknownType", ts.JSDocUnknownType]
    | ["JSDocNullableType", ts.JSDocNullableType]
    | ["JSDocNonNullableType", ts.JSDocNonNullableType]
    | ["JSDocOptionalType", ts.JSDocOptionalType]
    | ["JSDocFunctionType", ts.JSDocFunctionType]
    | ["JSDocVariadicType", ts.JSDocVariadicType]
    | ["JSDocNamepathType", ts.JSDocNamepathType]
    // | [ "JSDocComment", ts.JSDocComment ]
    | ["JSDocTypeLiteral", ts.JSDocTypeLiteral]
    | ["JSDocSignature", ts.JSDocSignature]
    | ["JSDocTag", ts.JSDocTag]
    | ["JSDocAugmentsTag", ts.JSDocAugmentsTag]
    | ["JSDocAuthorTag", ts.JSDocAuthorTag]
    | ["JSDocClassTag", ts.JSDocClassTag]
    | ["JSDocCallbackTag", ts.JSDocCallbackTag]
    | ["JSDocEnumTag", ts.JSDocEnumTag]
    | ["JSDocParameterTag", ts.JSDocParameterTag]
    | ["JSDocReturnTag", ts.JSDocReturnTag]
    | ["JSDocThisTag", ts.JSDocThisTag]
    | ["JSDocTypeTag", ts.JSDocTypeTag]
    | ["JSDocTemplateTag", ts.JSDocTemplateTag]
    | ["JSDocTypedefTag", ts.JSDocTypedefTag]
    | ["JSDocPropertyTag", ts.JSDocPropertyTag]
    | ["SyntaxList", ts.SyntaxList]
    | ["NotEmittedStatement", ts.NotEmittedStatement]
    | ["PartiallyEmittedExpression", ts.PartiallyEmittedExpression]
    | ["CommaListExpression", ts.CommaListExpression]
// | [ "MergeDeclarationMarker", ts.MergeDeclarationMarker ]
// | [ "EndOfDeclarationMarker", ts.EndOfDeclarationMarker ]
// | [ "Count", ts.Count ]


export function castNode(node: ts.Node): GeneratedTypedNode | null {
    switch (node.kind) {
        // case 0: return ["Unknown", node as ts.Unknown]
        //case 1: return ["EndOfFileToken", node as ts.EndOfFileToken]
        // case 2: return ["SingleLineCommentTrivia", node as ts.SingleLineCommentTrivia]
        // case 3: return ["MultiLineCommentTrivia", node as ts.MultiLineCommentTrivia]
        // case 4: return ["NewLineTrivia", node as ts.NewLineTrivia]
        // case 5: return ["WhitespaceTrivia", node as ts.WhitespaceTrivia]
        // case 6: return ["ShebangTrivia", node as ts.ShebangTrivia]
        // case 7: return ["ConflictMarkerTrivia", node as ts.ConflictMarkerTrivia]
        case 8: return ["NumericLiteral", node as ts.NumericLiteral]
        case 9: return ["BigIntLiteral", node as ts.BigIntLiteral]
        case 10: return ["StringLiteral", node as ts.StringLiteral]
        case 11: return ["JsxText", node as ts.JsxText]
        // case 12: return ["JsxTextAllWhiteSpaces", node as ts.JsxTextAllWhiteSpaces]
        case 13: return ["RegularExpressionLiteral", node as ts.RegularExpressionLiteral]
        case 14: return ["NoSubstitutionTemplateLiteral", node as ts.NoSubstitutionTemplateLiteral]
        case 15: return ["TemplateHead", node as ts.TemplateHead]
        case 16: return ["TemplateMiddle", node as ts.TemplateMiddle]
        case 17: return ["TemplateTail", node as ts.TemplateTail]
        // case 18: return ["OpenBraceToken", node as ts.OpenBraceToken]
        // case 19: return ["CloseBraceToken", node as ts.CloseBraceToken]
        // case 20: return ["OpenParenToken", node as ts.OpenParenToken]
        // case 21: return ["CloseParenToken", node as ts.CloseParenToken]
        // case 22: return ["OpenBracketToken", node as ts.OpenBracketToken]
        // case 23: return ["CloseBracketToken", node as ts.CloseBracketToken]
        // case 24: return ["DotToken", node as ts.DotToken]
        case 25: return ["DotDotDotToken", node as ts.DotDotDotToken]
        // case 26: return ["SemicolonToken", node as ts.SemicolonToken]
        // case 27: return ["CommaToken", node as ts.CommaToken]
        // case 28: return ["LessThanToken", node as ts.LessThanToken]
        // case 29: return ["LessThanSlashToken", node as ts.LessThanSlashToken]
        // case 30: return ["GreaterThanToken", node as ts.GreaterThanToken]
        // case 31: return ["LessThanEqualsToken", node as ts.LessThanEqualsToken]
        // case 32: return ["GreaterThanEqualsToken", node as ts.GreaterThanEqualsToken]
        // case 33: return ["EqualsEqualsToken", node as ts.EqualsEqualsToken]
        // case 34: return ["ExclamationEqualsToken", node as ts.ExclamationEqualsToken]
        // case 35: return ["EqualsEqualsEqualsToken", node as ts.EqualsEqualsEqualsToken]
        // case 36: return ["ExclamationEqualsEqualsToken", node as ts.ExclamationEqualsEqualsToken]
        case 37: return ["EqualsGreaterThanToken", node as ts.EqualsGreaterThanToken]
        case 38: return ["PlusToken", node as ts.PlusToken]
        case 39: return ["MinusToken", node as ts.MinusToken]
        case 40: return ["AsteriskToken", node as ts.AsteriskToken]
        // case 41: return ["AsteriskAsteriskToken", node as ts.AsteriskAsteriskToken]
        // case 42: return ["SlashToken", node as ts.SlashToken]
        // case 43: return ["PercentToken", node as ts.PercentToken]
        // case 44: return ["PlusPlusToken", node as ts.PlusPlusToken]
        // case 45: return ["MinusMinusToken", node as ts.MinusMinusToken]
        // case 46: return ["LessThanLessThanToken", node as ts.LessThanLessThanToken]
        // case 47: return ["GreaterThanGreaterThanToken", node as ts.GreaterThanGreaterThanToken]
        // case 48: return ["GreaterThanGreaterThanGreaterThanToken", node as ts.GreaterThanGreaterThanGreaterThanToken]
        // case 49: return ["AmpersandToken", node as ts.AmpersandToken]
        // case 50: return ["BarToken", node as ts.BarToken]
        // case 51: return ["CaretToken", node as ts.CaretToken]
        case 52: return ["ExclamationToken", node as ts.ExclamationToken]
        // case 53: return ["TildeToken", node as ts.TildeToken]
        // case 54: return ["AmpersandAmpersandToken", node as ts.AmpersandAmpersandToken]
        // case 55: return ["BarBarToken", node as ts.BarBarToken]
        case 56: return ["QuestionToken", node as ts.QuestionToken]
        case 57: return ["ColonToken", node as ts.ColonToken]
        // case 58: return ["AtToken", node as ts.AtToken]
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        // case 59: return ["BacktickToken", node as ts.BacktickToken]
        case 60: return ["EqualsToken", node as ts.EqualsToken]
        // case 61: return ["PlusEqualsToken", node as ts.PlusEqualsToken]
        // case 62: return ["MinusEqualsToken", node as ts.MinusEqualsToken]
        // case 63: return ["AsteriskEqualsToken", node as ts.AsteriskEqualsToken]
        // case 64: return ["AsteriskAsteriskEqualsToken", node as ts.AsteriskAsteriskEqualsToken]
        // case 65: return ["SlashEqualsToken", node as ts.SlashEqualsToken]
        // case 66: return ["PercentEqualsToken", node as ts.PercentEqualsToken]
        // case 67: return ["LessThanLessThanEqualsToken", node as ts.LessThanLessThanEqualsToken]
        // case 68: return ["GreaterThanGreaterThanEqualsToken", node as ts.GreaterThanGreaterThanEqualsToken]
        // case 69: return ["GreaterThanGreaterThanGreaterThanEqualsToken", node as ts.GreaterThanGreaterThanGreaterThanEqualsToken]
        // case 70: return ["AmpersandEqualsToken", node as ts.AmpersandEqualsToken]
        // case 71: return ["BarEqualsToken", node as ts.BarEqualsToken]
        // case 72: return ["CaretEqualsToken", node as ts.CaretEqualsToken]
        case 73: return ["Identifier", node as ts.Identifier]
        // case 74: return ["BreakKeyword", node as ts.BreakKeyword]
        // case 75: return ["CaseKeyword", node as ts.CaseKeyword]
        // case 76: return ["CatchKeyword", node as ts.CatchKeyword]
        // case 77: return ["ClassKeyword", node as ts.ClassKeyword]
        // case 78: return ["ConstKeyword", node as ts.ConstKeyword]
        // case 79: return ["ContinueKeyword", node as ts.ContinueKeyword]
        // case 80: return ["DebuggerKeyword", node as ts.DebuggerKeyword]
        // case 81: return ["DefaultKeyword", node as ts.DefaultKeyword]
        // case 82: return ["DeleteKeyword", node as ts.DeleteKeyword]
        // case 83: return ["DoKeyword", node as ts.DoKeyword]
        // case 84: return ["ElseKeyword", node as ts.ElseKeyword]
        // case 85: return ["EnumKeyword", node as ts.EnumKeyword]
        // case 86: return ["ExportKeyword", node as ts.ExportKeyword]
        // case 87: return ["ExtendsKeyword", node as ts.ExtendsKeyword]
        // case 88: return ["FalseKeyword", node as ts.FalseKeyword]
        // case 89: return ["FinallyKeyword", node as ts.FinallyKeyword]
        // case 90: return ["ForKeyword", node as ts.ForKeyword]
        // case 91: return ["FunctionKeyword", node as ts.FunctionKeyword]
        // case 92: return ["IfKeyword", node as ts.IfKeyword]
        // case 93: return ["ImportKeyword", node as ts.ImportKeyword]
        // case 94: return ["InKeyword", node as ts.InKeyword]
        // case 95: return ["InstanceOfKeyword", node as ts.InstanceOfKeyword]
        // case 96: return ["NewKeyword", node as ts.NewKeyword]
        // case 97: return ["NullKeyword", node as ts.NullKeyword]
        // case 98: return ["ReturnKeyword", node as ts.ReturnKeyword]
        // case 99: return ["SuperKeyword", node as ts.SuperKeyword]
        // case 100: return ["SwitchKeyword", node as ts.SwitchKeyword]
        // case 101: return ["ThisKeyword", node as ts.ThisKeyword]
        // case 102: return ["ThrowKeyword", node as ts.ThrowKeyword]
        // case 103: return ["TrueKeyword", node as ts.TrueKeyword]
        // case 104: return ["TryKeyword", node as ts.TryKeyword]
        // case 105: return ["TypeOfKeyword", node as ts.TypeOfKeyword]
        // case 106: return ["VarKeyword", node as ts.VarKeyword]
        // case 107: return ["VoidKeyword", node as ts.VoidKeyword]
        // case 108: return ["WhileKeyword", node as ts.WhileKeyword]
        // case 109: return ["WithKeyword", node as ts.WithKeyword]
        // case 110: return ["ImplementsKeyword", node as ts.ImplementsKeyword]
        // case 111: return ["InterfaceKeyword", node as ts.InterfaceKeyword]
        // case 112: return ["LetKeyword", node as ts.LetKeyword]
        // case 113: return ["PackageKeyword", node as ts.PackageKeyword]
        // case 114: return ["PrivateKeyword", node as ts.PrivateKeyword]
        // case 115: return ["ProtectedKeyword", node as ts.ProtectedKeyword]
        // case 116: return ["PublicKeyword", node as ts.PublicKeyword]
        // case 117: return ["StaticKeyword", node as ts.StaticKeyword]
        // case 118: return ["YieldKeyword", node as ts.YieldKeyword]
        // case 119: return ["AbstractKeyword", node as ts.AbstractKeyword]
        // case 120: return ["AsKeyword", node as ts.AsKeyword]
        // case 121: return ["AnyKeyword", node as ts.AnyKeyword]
        // case 122: return ["AsyncKeyword", node as ts.AsyncKeyword]
        // case 123: return ["AwaitKeyword", node as ts.AwaitKeyword]
        // case 124: return ["BooleanKeyword", node as ts.BooleanKeyword]
        // case 125: return ["ConstructorKeyword", node as ts.ConstructorKeyword]
        // case 126: return ["DeclareKeyword", node as ts.DeclareKeyword]
        // case 127: return ["GetKeyword", node as ts.GetKeyword]
        // case 128: return ["InferKeyword", node as ts.InferKeyword]
        // case 129: return ["IsKeyword", node as ts.IsKeyword]
        // case 130: return ["KeyOfKeyword", node as ts.KeyOfKeyword]
        // case 131: return ["ModuleKeyword", node as ts.ModuleKeyword]
        // case 132: return ["NamespaceKeyword", node as ts.NamespaceKeyword]
        // case 133: return ["NeverKeyword", node as ts.NeverKeyword]
        // case 134: return ["ReadonlyKeyword", node as ts.ReadonlyKeyword]
        // case 135: return ["RequireKeyword", node as ts.RequireKeyword]
        // case 136: return ["NumberKeyword", node as ts.NumberKeyword]
        // case 137: return ["ObjectKeyword", node as ts.ObjectKeyword]
        // case 138: return ["SetKeyword", node as ts.SetKeyword]
        // case 139: return ["StringKeyword", node as ts.StringKeyword]
        // case 140: return ["SymbolKeyword", node as ts.SymbolKeyword]
        // case 141: return ["TypeKeyword", node as ts.TypeKeyword]
        // case 142: return ["UndefinedKeyword", node as ts.UndefinedKeyword]
        // case 143: return ["UniqueKeyword", node as ts.UniqueKeyword]
        // case 144: return ["UnknownKeyword", node as ts.UnknownKeyword]
        // case 145: return ["FromKeyword", node as ts.FromKeyword]
        // case 146: return ["GlobalKeyword", node as ts.GlobalKeyword]
        // case 147: return ["BigIntKeyword", node as ts.BigIntKeyword]
        // case 148: return ["OfKeyword", node as ts.OfKeyword]
        case 149: return ["QualifiedName", node as ts.QualifiedName]
        case 150: return ["ComputedPropertyName", node as ts.ComputedPropertyName]
        // case 151: return ["TypeParameter", node as ts.TypeParameter]
        // case 152: return ["Parameter", node as ts.Parameter]
        case 153: return ["Decorator", node as ts.Decorator]
        case 154: return ["PropertySignature", node as ts.PropertySignature]
        case 155: return ["PropertyDeclaration", node as ts.PropertyDeclaration]
        case 156: return ["MethodSignature", node as ts.MethodSignature]
        case 157: return ["MethodDeclaration", node as ts.MethodDeclaration]
        // case 158: return ["Constructor", node as ts.Constructor]
        // case 159: return ["GetAccessor", node as ts.GetAccessor]
        // case 160: return ["SetAccessor", node as ts.SetAccessor]
        // case 161: return ["CallSignature", node as ts.CallSignature]
        // case 162: return ["ConstructSignature", node as ts.ConstructSignature]
        // case 163: return ["IndexSignature", node as ts.IndexSignature]
        // case 164: return ["TypePredicate", node as ts.TypePredicate]
        // case 165: return ["TypeReference", node as ts.TypeReference]
        // case 166: return ["FunctionType", node as ts.FunctionType]
        // case 167: return ["ConstructorType", node as ts.ConstructorType]
        // case 168: return ["TypeQuery", node as ts.TypeQuery]
        // case 169: return ["TypeLiteral", node as ts.TypeLiteral]
        // case 170: return ["ArrayType", node as ts.ArrayType]
        // case 171: return ["TupleType", node as ts.TupleType]
        // case 172: return ["OptionalType", node as ts.OptionalType]
        // case 173: return ["RestType", node as ts.RestType]
        // case 174: return ["UnionType", node as ts.UnionType]
        // case 175: return ["IntersectionType", node as ts.IntersectionType]
        // case 176: return ["ConditionalType", node as ts.ConditionalType]
        // case 177: return ["InferType", node as ts.InferType]
        // case 178: return ["ParenthesizedType", node as ts.ParenthesizedType]
        // case 179: return ["ThisType", node as ts.ThisType]
        // case 180: return ["TypeOperator", node as ts.TypeOperator]
        // case 181: return ["IndexedAccessType", node as ts.IndexedAccessType]
        // case 182: return ["MappedType", node as ts.MappedType]
        // case 183: return ["LiteralType", node as ts.LiteralType]
        // case 184: return ["ImportType", node as ts.ImportType]
        case 185: return ["ObjectBindingPattern", node as ts.ObjectBindingPattern]
        case 186: return ["ArrayBindingPattern", node as ts.ArrayBindingPattern]
        case 187: return ["BindingElement", node as ts.BindingElement]
        case 188: return ["ArrayLiteralExpression", node as ts.ArrayLiteralExpression]
        case 189: return ["ObjectLiteralExpression", node as ts.ObjectLiteralExpression]
        case 190: return ["PropertyAccessExpression", node as ts.PropertyAccessExpression]
        case 191: return ["ElementAccessExpression", node as ts.ElementAccessExpression]
        case 192: return ["CallExpression", node as ts.CallExpression]
        case 193: return ["NewExpression", node as ts.NewExpression]
        case 194: return ["TaggedTemplateExpression", node as ts.TaggedTemplateExpression]
        // case 195: return ["TypeAssertionExpression", node as ts.TypeAssertionExpression]
        case 196: return ["ParenthesizedExpression", node as ts.ParenthesizedExpression]
        case 197: return ["FunctionExpression", node as ts.FunctionExpression]
        case 198: return ["ArrowFunction", node as ts.ArrowFunction]
        case 199: return ["DeleteExpression", node as ts.DeleteExpression]
        case 200: return ["TypeOfExpression", node as ts.TypeOfExpression]
        case 201: return ["VoidExpression", node as ts.VoidExpression]
        case 202: return ["AwaitExpression", node as ts.AwaitExpression]
        case 203: return ["PrefixUnaryExpression", node as ts.PrefixUnaryExpression]
        case 204: return ["PostfixUnaryExpression", node as ts.PostfixUnaryExpression]
        case 205: return ["BinaryExpression", node as ts.BinaryExpression]
        case 206: return ["ConditionalExpression", node as ts.ConditionalExpression]
        case 207: return ["TemplateExpression", node as ts.TemplateExpression]
        case 208: return ["YieldExpression", node as ts.YieldExpression]
        case 209: return ["SpreadElement", node as ts.SpreadElement]
        case 210: return ["ClassExpression", node as ts.ClassExpression]
        case 211: return ["OmittedExpression", node as ts.OmittedExpression]
        case 212: return ["ExpressionWithTypeArguments", node as ts.ExpressionWithTypeArguments]
        case 213: return ["AsExpression", node as ts.AsExpression]
        case 214: return ["NonNullExpression", node as ts.NonNullExpression]
        case 215: return ["MetaProperty", node as ts.MetaProperty]
        case 216: return ["SyntheticExpression", node as ts.SyntheticExpression]
        case 217: return ["TemplateSpan", node as ts.TemplateSpan]
        case 218: return ["SemicolonClassElement", node as ts.SemicolonClassElement]
        case 219: return ["Block", node as ts.Block]
        case 220: return ["VariableStatement", node as ts.VariableStatement]
        case 221: return ["EmptyStatement", node as ts.EmptyStatement]
        case 222: return ["ExpressionStatement", node as ts.ExpressionStatement]
        case 223: return ["IfStatement", node as ts.IfStatement]
        case 224: return ["DoStatement", node as ts.DoStatement]
        case 225: return ["WhileStatement", node as ts.WhileStatement]
        case 226: return ["ForStatement", node as ts.ForStatement]
        case 227: return ["ForInStatement", node as ts.ForInStatement]
        case 228: return ["ForOfStatement", node as ts.ForOfStatement]
        case 229: return ["ContinueStatement", node as ts.ContinueStatement]
        case 230: return ["BreakStatement", node as ts.BreakStatement]
        case 231: return ["ReturnStatement", node as ts.ReturnStatement]
        case 232: return ["WithStatement", node as ts.WithStatement]
        case 233: return ["SwitchStatement", node as ts.SwitchStatement]
        case 234: return ["LabeledStatement", node as ts.LabeledStatement]
        case 235: return ["ThrowStatement", node as ts.ThrowStatement]
        case 236: return ["TryStatement", node as ts.TryStatement]
        case 237: return ["DebuggerStatement", node as ts.DebuggerStatement]
        case 238: return ["VariableDeclaration", node as ts.VariableDeclaration]
        case 239: return ["VariableDeclarationList", node as ts.VariableDeclarationList]
        case 240: return ["FunctionDeclaration", node as ts.FunctionDeclaration]
        case 241: return ["ClassDeclaration", node as ts.ClassDeclaration]
        case 242: return ["InterfaceDeclaration", node as ts.InterfaceDeclaration]
        case 243: return ["TypeAliasDeclaration", node as ts.TypeAliasDeclaration]
        case 244: return ["EnumDeclaration", node as ts.EnumDeclaration]
        case 245: return ["ModuleDeclaration", node as ts.ModuleDeclaration]
        case 246: return ["ModuleBlock", node as ts.ModuleBlock]
        case 247: return ["CaseBlock", node as ts.CaseBlock]
        case 248: return ["NamespaceExportDeclaration", node as ts.NamespaceExportDeclaration]
        case 249: return ["ImportEqualsDeclaration", node as ts.ImportEqualsDeclaration]
        case 250: return ["ImportDeclaration", node as ts.ImportDeclaration]
        case 251: return ["ImportClause", node as ts.ImportClause]
        case 252: return ["NamespaceImport", node as ts.NamespaceImport]
        case 253: return ["NamedImports", node as ts.NamedImports]
        case 254: return ["ImportSpecifier", node as ts.ImportSpecifier]
        case 255: return ["ExportAssignment", node as ts.ExportAssignment]
        case 256: return ["ExportDeclaration", node as ts.ExportDeclaration]
        case 257: return ["NamedExports", node as ts.NamedExports]
        case 258: return ["ExportSpecifier", node as ts.ExportSpecifier]
        case 259: return ["MissingDeclaration", node as ts.MissingDeclaration]
        case 260: return ["ExternalModuleReference", node as ts.ExternalModuleReference]
        case 261: return ["JsxElement", node as ts.JsxElement]
        case 262: return ["JsxSelfClosingElement", node as ts.JsxSelfClosingElement]
        case 263: return ["JsxOpeningElement", node as ts.JsxOpeningElement]
        case 264: return ["JsxClosingElement", node as ts.JsxClosingElement]
        case 265: return ["JsxFragment", node as ts.JsxFragment]
        case 266: return ["JsxOpeningFragment", node as ts.JsxOpeningFragment]
        case 267: return ["JsxClosingFragment", node as ts.JsxClosingFragment]
        case 268: return ["JsxAttribute", node as ts.JsxAttribute]
        case 269: return ["JsxAttributes", node as ts.JsxAttributes]
        case 270: return ["JsxSpreadAttribute", node as ts.JsxSpreadAttribute]
        case 271: return ["JsxExpression", node as ts.JsxExpression]
        case 272: return ["CaseClause", node as ts.CaseClause]
        case 273: return ["DefaultClause", node as ts.DefaultClause]
        case 274: return ["HeritageClause", node as ts.HeritageClause]
        case 275: return ["CatchClause", node as ts.CatchClause]
        case 276: return ["PropertyAssignment", node as ts.PropertyAssignment]
        case 277: return ["ShorthandPropertyAssignment", node as ts.ShorthandPropertyAssignment]
        case 278: return ["SpreadAssignment", node as ts.SpreadAssignment]
        case 279: return ["EnumMember", node as ts.EnumMember]
        case 280: return ["UnparsedPrologue", node as ts.UnparsedPrologue]
        case 281: return ["UnparsedPrepend", node as ts.UnparsedPrepend]
        // case 282: return ["UnparsedText", node as ts.UnparsedText]
        // case 283: return ["UnparsedInternalText", node as ts.UnparsedInternalText]
        case 284: return ["UnparsedSyntheticReference", node as ts.UnparsedSyntheticReference]
        case 285: return ["SourceFile", node as ts.SourceFile]
        case 286: return ["Bundle", node as ts.Bundle]
        case 287: return ["UnparsedSource", node as ts.UnparsedSource]
        case 288: return ["InputFiles", node as ts.InputFiles]
        case 289: return ["JSDocTypeExpression", node as ts.JSDocTypeExpression]
        case 290: return ["JSDocAllType", node as ts.JSDocAllType]
        case 291: return ["JSDocUnknownType", node as ts.JSDocUnknownType]
        case 292: return ["JSDocNullableType", node as ts.JSDocNullableType]
        case 293: return ["JSDocNonNullableType", node as ts.JSDocNonNullableType]
        case 294: return ["JSDocOptionalType", node as ts.JSDocOptionalType]
        case 295: return ["JSDocFunctionType", node as ts.JSDocFunctionType]
        case 296: return ["JSDocVariadicType", node as ts.JSDocVariadicType]
        case 297: return ["JSDocNamepathType", node as ts.JSDocNamepathType]
        // case 298: return ["JSDocComment", node as ts.JSDocComment]
        case 299: return ["JSDocTypeLiteral", node as ts.JSDocTypeLiteral]
        case 300: return ["JSDocSignature", node as ts.JSDocSignature]
        case 301: return ["JSDocTag", node as ts.JSDocTag]
        case 302: return ["JSDocAugmentsTag", node as ts.JSDocAugmentsTag]
        case 303: return ["JSDocAuthorTag", node as ts.JSDocAuthorTag]
        case 304: return ["JSDocClassTag", node as ts.JSDocClassTag]
        case 305: return ["JSDocCallbackTag", node as ts.JSDocCallbackTag]
        case 306: return ["JSDocEnumTag", node as ts.JSDocEnumTag]
        case 307: return ["JSDocParameterTag", node as ts.JSDocParameterTag]
        case 308: return ["JSDocReturnTag", node as ts.JSDocReturnTag]
        case 309: return ["JSDocThisTag", node as ts.JSDocThisTag]
        case 310: return ["JSDocTypeTag", node as ts.JSDocTypeTag]
        case 311: return ["JSDocTemplateTag", node as ts.JSDocTemplateTag]
        case 312: return ["JSDocTypedefTag", node as ts.JSDocTypedefTag]
        case 313: return ["JSDocPropertyTag", node as ts.JSDocPropertyTag]
        case 314: return ["SyntaxList", node as ts.SyntaxList]
        case 315: return ["NotEmittedStatement", node as ts.NotEmittedStatement]
        case 316: return ["PartiallyEmittedExpression", node as ts.PartiallyEmittedExpression]
        case 317: return ["CommaListExpression", node as ts.CommaListExpression]
        // case 318: return ["MergeDeclarationMarker", node as ts.MergeDeclarationMarker]
        // case 319: return ["EndOfDeclarationMarker", node as ts.EndOfDeclarationMarker]
        // case 320: return ["Count", node as ts.Count]
        default: return null
    }
}


export type GeneratedUncastableNode =
    | ["Unknown"]
    // | ["EndOfFileToken"]
    | ["SingleLineCommentTrivia"]
    | ["MultiLineCommentTrivia"]
    | ["NewLineTrivia"]
    | ["WhitespaceTrivia"]
    | ["ShebangTrivia"]
    | ["ConflictMarkerTrivia"]
    // | ["NumericLiteral"]
    // | ["BigIntLiteral"]
    // | ["StringLiteral"]
    // | ["JsxText"]
    | ["JsxTextAllWhiteSpaces"]
    // | ["RegularExpressionLiteral"]
    // | ["NoSubstitutionTemplateLiteral"]
    // | ["TemplateHead"]
    // | ["TemplateMiddle"]
    // | ["TemplateTail"]
    | ["OpenBraceToken"]
    | ["CloseBraceToken"]
    | ["OpenParenToken"]
    | ["CloseParenToken"]
    | ["OpenBracketToken"]
    | ["CloseBracketToken"]
    | ["DotToken"]
    // | ["DotDotDotToken"]
    | ["SemicolonToken"]
    | ["CommaToken"]
    | ["LessThanToken"]
    | ["LessThanSlashToken"]
    | ["GreaterThanToken"]
    | ["LessThanEqualsToken"]
    | ["GreaterThanEqualsToken"]
    | ["EqualsEqualsToken"]
    | ["ExclamationEqualsToken"]
    | ["EqualsEqualsEqualsToken"]
    | ["ExclamationEqualsEqualsToken"]
    // | ["EqualsGreaterThanToken"]
    // | ["PlusToken"]
    // | ["MinusToken"]
    // | ["AsteriskToken"]
    | ["AsteriskAsteriskToken"]
    | ["SlashToken"]
    | ["PercentToken"]
    | ["PlusPlusToken"]
    | ["MinusMinusToken"]
    | ["LessThanLessThanToken"]
    | ["GreaterThanGreaterThanToken"]
    | ["GreaterThanGreaterThanGreaterThanToken"]
    | ["AmpersandToken"]
    | ["BarToken"]
    | ["CaretToken"]
    // | ["ExclamationToken"]
    | ["TildeToken"]
    | ["AmpersandAmpersandToken"]
    | ["BarBarToken"]
    // | ["QuestionToken"]
    // | ["ColonToken"]
    | ["AtToken"]
    /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
    | ["BacktickToken"]
    // | ["EqualsToken"]
    | ["PlusEqualsToken"]
    | ["MinusEqualsToken"]
    | ["AsteriskEqualsToken"]
    | ["AsteriskAsteriskEqualsToken"]
    | ["SlashEqualsToken"]
    | ["PercentEqualsToken"]
    | ["LessThanLessThanEqualsToken"]
    | ["GreaterThanGreaterThanEqualsToken"]
    | ["GreaterThanGreaterThanGreaterThanEqualsToken"]
    | ["AmpersandEqualsToken"]
    | ["BarEqualsToken"]
    | ["CaretEqualsToken"]
    // | ["Identifier"]
    | ["BreakKeyword"]
    | ["CaseKeyword"]
    | ["CatchKeyword"]
    | ["ClassKeyword"]
    | ["ConstKeyword"]
    | ["ContinueKeyword"]
    | ["DebuggerKeyword"]
    | ["DefaultKeyword"]
    | ["DeleteKeyword"]
    | ["DoKeyword"]
    | ["ElseKeyword"]
    | ["EnumKeyword"]
    | ["ExportKeyword"]
    | ["ExtendsKeyword"]
    | ["FalseKeyword"]
    | ["FinallyKeyword"]
    | ["ForKeyword"]
    | ["FunctionKeyword"]
    | ["IfKeyword"]
    | ["ImportKeyword"]
    | ["InKeyword"]
    | ["InstanceOfKeyword"]
    | ["NewKeyword"]
    //| ["NullKeyword"]
    | ["ReturnKeyword"]
    | ["SuperKeyword"]
    | ["SwitchKeyword"]
    | ["ThisKeyword"]
    | ["ThrowKeyword"]
    | ["TrueKeyword"]
    | ["TryKeyword"]
    | ["TypeOfKeyword"]
    | ["VarKeyword"]
    | ["VoidKeyword"]
    | ["WhileKeyword"]
    | ["WithKeyword"]
    | ["ImplementsKeyword"]
    | ["InterfaceKeyword"]
    | ["LetKeyword"]
    | ["PackageKeyword"]
    | ["PrivateKeyword"]
    | ["ProtectedKeyword"]
    | ["PublicKeyword"]
    | ["StaticKeyword"]
    | ["YieldKeyword"]
    | ["AbstractKeyword"]
    | ["AsKeyword"]
    | ["AnyKeyword"]
    | ["AsyncKeyword"]
    | ["AwaitKeyword"]
    | ["BooleanKeyword"]
    | ["ConstructorKeyword"]
    | ["DeclareKeyword"]
    | ["GetKeyword"]
    | ["InferKeyword"]
    | ["IsKeyword"]
    | ["KeyOfKeyword"]
    | ["ModuleKeyword"]
    | ["NamespaceKeyword"]
    | ["NeverKeyword"]
    | ["ReadonlyKeyword"]
    | ["RequireKeyword"]
    | ["NumberKeyword"]
    | ["ObjectKeyword"]
    | ["SetKeyword"]
    | ["StringKeyword"]
    | ["SymbolKeyword"]
    | ["TypeKeyword"]
    | ["UndefinedKeyword"]
    | ["UniqueKeyword"]
    | ["UnknownKeyword"]
    | ["FromKeyword"]
    | ["GlobalKeyword"]
    | ["BigIntKeyword"]
    | ["OfKeyword"]
    // | ["QualifiedName"]
    // | ["ComputedPropertyName"]
    | ["TypeParameter"]
    | ["Parameter"]
    // | ["Decorator"]
    // | ["PropertySignature"]
    // | ["PropertyDeclaration"]
    // | ["MethodSignature"]
    // | ["MethodDeclaration"]
    | ["Constructor"]
    | ["GetAccessor"]
    | ["SetAccessor"]
    | ["CallSignature"]
    | ["ConstructSignature"]
    | ["IndexSignature"]
    | ["TypePredicate"]
    | ["TypeReference"]
    | ["FunctionType"]
    | ["ConstructorType"]
    | ["TypeQuery"]
    | ["TypeLiteral"]
    | ["ArrayType"]
    | ["TupleType"]
    | ["OptionalType"]
    | ["RestType"]
    | ["UnionType"]
    | ["IntersectionType"]
    | ["ConditionalType"]
    | ["InferType"]
    | ["ParenthesizedType"]
    | ["ThisType"]
    | ["TypeOperator"]
    | ["IndexedAccessType"]
    | ["MappedType"]
    | ["LiteralType"]
    | ["ImportType"]
    // | ["ObjectBindingPattern"]
    // | ["ArrayBindingPattern"]
    // | ["BindingElement"]
    // | ["ArrayLiteralExpression"]
    // | ["ObjectLiteralExpression"]
    // | ["PropertyAccessExpression"]
    // | ["ElementAccessExpression"]
    // | ["CallExpression"]
    // | ["NewExpression"]
    // | ["TaggedTemplateExpression"]
    | ["TypeAssertionExpression"]
    // | ["ParenthesizedExpression"]
    // | ["FunctionExpression"]
    // | ["ArrowFunction"]
    // | ["DeleteExpression"]
    // | ["TypeOfExpression"]
    // | ["VoidExpression"]
    // | ["AwaitExpression"]
    // | ["PrefixUnaryExpression"]
    // | ["PostfixUnaryExpression"]
    // | ["BinaryExpression"]
    // | ["ConditionalExpression"]
    // | ["TemplateExpression"]
    // | ["YieldExpression"]
    // | ["SpreadElement"]
    // | ["ClassExpression"]
    // | ["OmittedExpression"]
    // | ["ExpressionWithTypeArguments"]
    // | ["AsExpression"]
    // | ["NonNullExpression"]
    // | ["MetaProperty"]
    // | ["SyntheticExpression"]
    // | ["TemplateSpan"]
    // | ["SemicolonClassElement"]
    // | ["Block"]
    // | ["VariableStatement"]
    // | ["EmptyStatement"]
    // | ["ExpressionStatement"]
    // | ["IfStatement"]
    // | ["DoStatement"]
    // | ["WhileStatement"]
    // | ["ForStatement"]
    // | ["ForInStatement"]
    // | ["ForOfStatement"]
    // | ["ContinueStatement"]
    // | ["BreakStatement"]
    // | ["ReturnStatement"]
    // | ["WithStatement"]
    // | ["SwitchStatement"]
    // | ["LabeledStatement"]
    // | ["ThrowStatement"]
    // | ["TryStatement"]
    // | ["DebuggerStatement"]
    // | ["VariableDeclaration"]
    // | ["VariableDeclarationList"]
    // | ["FunctionDeclaration"]
    // | ["ClassDeclaration"]
    // | ["InterfaceDeclaration"]
    // | ["TypeAliasDeclaration"]
    // | ["EnumDeclaration"]
    // | ["ModuleDeclaration"]
    // | ["ModuleBlock"]
    // | ["CaseBlock"]
    // | ["NamespaceExportDeclaration"]
    // | ["ImportEqualsDeclaration"]
    // | ["ImportDeclaration"]
    // | ["ImportClause"]
    // | ["NamespaceImport"]
    // | ["NamedImports"]
    // | ["ImportSpecifier"]
    // | ["ExportAssignment"]
    // | ["ExportDeclaration"]
    // | ["NamedExports"]
    // | ["ExportSpecifier"]
    // | ["MissingDeclaration"]
    // | ["ExternalModuleReference"]
    // | ["JsxElement"]
    // | ["JsxSelfClosingElement"]
    // | ["JsxOpeningElement"]
    // | ["JsxClosingElement"]
    // | ["JsxFragment"]
    // | ["JsxOpeningFragment"]
    // | ["JsxClosingFragment"]
    // | ["JsxAttribute"]
    // | ["JsxAttributes"]
    // | ["JsxSpreadAttribute"]
    // | ["JsxExpression"]
    // | ["CaseClause"]
    // | ["DefaultClause"]
    // | ["HeritageClause"]
    // | ["CatchClause"]
    // | ["PropertyAssignment"]
    // | ["ShorthandPropertyAssignment"]
    // | ["SpreadAssignment"]
    // | ["EnumMember"]
    // | ["UnparsedPrologue"]
    // | ["UnparsedPrepend"]
    | ["UnparsedText"]
    | ["UnparsedInternalText"]
    // | ["UnparsedSyntheticReference"]
    // | ["SourceFile"]
    // | ["Bundle"]
    // | ["UnparsedSource"]
    // | ["InputFiles"]
    // | ["JSDocTypeExpression"]
    // | ["JSDocAllType"]
    // | ["JSDocUnknownType"]
    // | ["JSDocNullableType"]
    // | ["JSDocNonNullableType"]
    // | ["JSDocOptionalType"]
    // | ["JSDocFunctionType"]
    // | ["JSDocVariadicType"]
    // | ["JSDocNamepathType"]
    | ["JSDocComment"]
    // | ["JSDocTypeLiteral"]
    // | ["JSDocSignature"]
    // | ["JSDocTag"]
    // | ["JSDocAugmentsTag"]
    // | ["JSDocAuthorTag"]
    // | ["JSDocClassTag"]
    // | ["JSDocCallbackTag"]
    // | ["JSDocEnumTag"]
    // | ["JSDocParameterTag"]
    // | ["JSDocReturnTag"]
    // | ["JSDocThisTag"]
    // | ["JSDocTypeTag"]
    // | ["JSDocTemplateTag"]
    // | ["JSDocTypedefTag"]
    // | ["JSDocPropertyTag"]
    // | ["SyntaxList"]
    // | ["NotEmittedStatement"]
    // | ["PartiallyEmittedExpression"]
    // | ["CommaListExpression"]
    | ["MergeDeclarationMarker"]
    | ["EndOfDeclarationMarker"]
    | ["Count"]


export function castUnsupportedNode(node: ts.Node): GeneratedUncastableNode | null {
    switch (node.kind) {
        case 0: return ["Unknown"]
        // case 1: return ["EndOfFileToken"]
        case 2: return ["SingleLineCommentTrivia"]
        case 3: return ["MultiLineCommentTrivia"]
        case 4: return ["NewLineTrivia"]
        case 5: return ["WhitespaceTrivia"]
        case 6: return ["ShebangTrivia"]
        case 7: return ["ConflictMarkerTrivia"]
        // case 8: return ["NumericLiteral"]
        // case 9: return ["BigIntLiteral"]
        // case 10: return ["StringLiteral"]
        // case 11: return ["JsxText"]
        case 12: return ["JsxTextAllWhiteSpaces"]
        // case 13: return ["RegularExpressionLiteral"]
        // case 14: return ["NoSubstitutionTemplateLiteral"]
        // case 15: return ["TemplateHead"]
        // case 16: return ["TemplateMiddle"]
        // case 17: return ["TemplateTail"]
        case 18: return ["OpenBraceToken"]
        case 19: return ["CloseBraceToken"]
        case 20: return ["OpenParenToken"]
        case 21: return ["CloseParenToken"]
        case 22: return ["OpenBracketToken"]
        case 23: return ["CloseBracketToken"]
        case 24: return ["DotToken"]
        // case 25: return ["DotDotDotToken"]
        case 26: return ["SemicolonToken"]
        case 27: return ["CommaToken"]
        case 28: return ["LessThanToken"]
        case 29: return ["LessThanSlashToken"]
        case 30: return ["GreaterThanToken"]
        case 31: return ["LessThanEqualsToken"]
        case 32: return ["GreaterThanEqualsToken"]
        case 33: return ["EqualsEqualsToken"]
        case 34: return ["ExclamationEqualsToken"]
        case 35: return ["EqualsEqualsEqualsToken"]
        case 36: return ["ExclamationEqualsEqualsToken"]
        // case 37: return ["EqualsGreaterThanToken"]
        // case 38: return ["PlusToken"]
        // case 39: return ["MinusToken"]
        // case 40: return ["AsteriskToken"]
        case 41: return ["AsteriskAsteriskToken"]
        case 42: return ["SlashToken"]
        case 43: return ["PercentToken"]
        case 44: return ["PlusPlusToken"]
        case 45: return ["MinusMinusToken"]
        case 46: return ["LessThanLessThanToken"]
        case 47: return ["GreaterThanGreaterThanToken"]
        case 48: return ["GreaterThanGreaterThanGreaterThanToken"]
        case 49: return ["AmpersandToken"]
        case 50: return ["BarToken"]
        case 51: return ["CaretToken"]
        // case 52: return ["ExclamationToken"]
        case 53: return ["TildeToken"]
        case 54: return ["AmpersandAmpersandToken"]
        case 55: return ["BarBarToken"]
        // case 56: return ["QuestionToken"]
        // case 57: return ["ColonToken"]
        case 58: return ["AtToken"]
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        case 59: return ["BacktickToken"]
        // case 60: return ["EqualsToken"]
        case 61: return ["PlusEqualsToken"]
        case 62: return ["MinusEqualsToken"]
        case 63: return ["AsteriskEqualsToken"]
        case 64: return ["AsteriskAsteriskEqualsToken"]
        case 65: return ["SlashEqualsToken"]
        case 66: return ["PercentEqualsToken"]
        case 67: return ["LessThanLessThanEqualsToken"]
        case 68: return ["GreaterThanGreaterThanEqualsToken"]
        case 69: return ["GreaterThanGreaterThanGreaterThanEqualsToken"]
        case 70: return ["AmpersandEqualsToken"]
        case 71: return ["BarEqualsToken"]
        case 72: return ["CaretEqualsToken"]
        // case 73: return ["Identifier"]
        case 74: return ["BreakKeyword"]
        case 75: return ["CaseKeyword"]
        case 76: return ["CatchKeyword"]
        case 77: return ["ClassKeyword"]
        case 78: return ["ConstKeyword"]
        case 79: return ["ContinueKeyword"]
        case 80: return ["DebuggerKeyword"]
        case 81: return ["DefaultKeyword"]
        case 82: return ["DeleteKeyword"]
        case 83: return ["DoKeyword"]
        case 84: return ["ElseKeyword"]
        case 85: return ["EnumKeyword"]
        case 86: return ["ExportKeyword"]
        case 87: return ["ExtendsKeyword"]
        case 88: return ["FalseKeyword"]
        case 89: return ["FinallyKeyword"]
        case 90: return ["ForKeyword"]
        case 91: return ["FunctionKeyword"]
        case 92: return ["IfKeyword"]
        case 93: return ["ImportKeyword"]
        case 94: return ["InKeyword"]
        case 95: return ["InstanceOfKeyword"]
        case 96: return ["NewKeyword"]
        //case 97: return ["NullKeyword"]
        case 98: return ["ReturnKeyword"]
        case 99: return ["SuperKeyword"]
        case 100: return ["SwitchKeyword"]
        case 101: return ["ThisKeyword"]
        case 102: return ["ThrowKeyword"]
        case 103: return ["TrueKeyword"]
        case 104: return ["TryKeyword"]
        case 105: return ["TypeOfKeyword"]
        case 106: return ["VarKeyword"]
        case 107: return ["VoidKeyword"]
        case 108: return ["WhileKeyword"]
        case 109: return ["WithKeyword"]
        case 110: return ["ImplementsKeyword"]
        case 111: return ["InterfaceKeyword"]
        case 112: return ["LetKeyword"]
        case 113: return ["PackageKeyword"]
        case 114: return ["PrivateKeyword"]
        case 115: return ["ProtectedKeyword"]
        case 116: return ["PublicKeyword"]
        case 117: return ["StaticKeyword"]
        case 118: return ["YieldKeyword"]
        case 119: return ["AbstractKeyword"]
        case 120: return ["AsKeyword"]
        case 121: return ["AnyKeyword"]
        case 122: return ["AsyncKeyword"]
        case 123: return ["AwaitKeyword"]
        case 124: return ["BooleanKeyword"]
        case 125: return ["ConstructorKeyword"]
        case 126: return ["DeclareKeyword"]
        case 127: return ["GetKeyword"]
        case 128: return ["InferKeyword"]
        case 129: return ["IsKeyword"]
        case 130: return ["KeyOfKeyword"]
        case 131: return ["ModuleKeyword"]
        case 132: return ["NamespaceKeyword"]
        case 133: return ["NeverKeyword"]
        case 134: return ["ReadonlyKeyword"]
        case 135: return ["RequireKeyword"]
        case 136: return ["NumberKeyword"]
        case 137: return ["ObjectKeyword"]
        case 138: return ["SetKeyword"]
        case 139: return ["StringKeyword"]
        case 140: return ["SymbolKeyword"]
        case 141: return ["TypeKeyword"]
        case 142: return ["UndefinedKeyword"]
        case 143: return ["UniqueKeyword"]
        case 144: return ["UnknownKeyword"]
        case 145: return ["FromKeyword"]
        case 146: return ["GlobalKeyword"]
        case 147: return ["BigIntKeyword"]
        case 148: return ["OfKeyword"]
        // case 149: return ["QualifiedName"]
        // case 150: return ["ComputedPropertyName"]
        case 151: return ["TypeParameter"]
        case 152: return ["Parameter"]
        // case 153: return ["Decorator"]
        // case 154: return ["PropertySignature"]
        // case 155: return ["PropertyDeclaration"]
        // case 156: return ["MethodSignature"]
        // case 157: return ["MethodDeclaration"]
        case 158: return ["Constructor"]
        case 159: return ["GetAccessor"]
        case 160: return ["SetAccessor"]
        case 161: return ["CallSignature"]
        case 162: return ["ConstructSignature"]
        case 163: return ["IndexSignature"]
        case 164: return ["TypePredicate"]
        case 165: return ["TypeReference"]
        case 166: return ["FunctionType"]
        case 167: return ["ConstructorType"]
        case 168: return ["TypeQuery"]
        case 169: return ["TypeLiteral"]
        case 170: return ["ArrayType"]
        case 171: return ["TupleType"]
        case 172: return ["OptionalType"]
        case 173: return ["RestType"]
        case 174: return ["UnionType"]
        case 175: return ["IntersectionType"]
        case 176: return ["ConditionalType"]
        case 177: return ["InferType"]
        case 178: return ["ParenthesizedType"]
        case 179: return ["ThisType"]
        case 180: return ["TypeOperator"]
        case 181: return ["IndexedAccessType"]
        case 182: return ["MappedType"]
        case 183: return ["LiteralType"]
        case 184: return ["ImportType"]
        // case 185: return ["ObjectBindingPattern"]
        // case 186: return ["ArrayBindingPattern"]
        // case 187: return ["BindingElement"]
        // case 188: return ["ArrayLiteralExpression"]
        // case 189: return ["ObjectLiteralExpression"]
        // case 190: return ["PropertyAccessExpression"]
        // case 191: return ["ElementAccessExpression"]
        // case 192: return ["CallExpression"]
        // case 193: return ["NewExpression"]
        // case 194: return ["TaggedTemplateExpression"]
        case 195: return ["TypeAssertionExpression"]
        // case 196: return ["ParenthesizedExpression"]
        // case 197: return ["FunctionExpression"]
        // case 198: return ["ArrowFunction"]
        // case 199: return ["DeleteExpression"]
        // case 200: return ["TypeOfExpression"]
        // case 201: return ["VoidExpression"]
        // case 202: return ["AwaitExpression"]
        // case 203: return ["PrefixUnaryExpression"]
        // case 204: return ["PostfixUnaryExpression"]
        // case 205: return ["BinaryExpression"]
        // case 206: return ["ConditionalExpression"]
        // case 207: return ["TemplateExpression"]
        // case 208: return ["YieldExpression"]
        // case 209: return ["SpreadElement"]
        // case 210: return ["ClassExpression"]
        // case 211: return ["OmittedExpression"]
        // case 212: return ["ExpressionWithTypeArguments"]
        // case 213: return ["AsExpression"]
        // case 214: return ["NonNullExpression"]
        // case 215: return ["MetaProperty"]
        // case 216: return ["SyntheticExpression"]
        // case 217: return ["TemplateSpan"]
        // case 218: return ["SemicolonClassElement"]
        // case 219: return ["Block"]
        // case 220: return ["VariableStatement"]
        // case 221: return ["EmptyStatement"]
        // case 222: return ["ExpressionStatement"]
        // case 223: return ["IfStatement"]
        // case 224: return ["DoStatement"]
        // case 225: return ["WhileStatement"]
        // case 226: return ["ForStatement"]
        // case 227: return ["ForInStatement"]
        // case 228: return ["ForOfStatement"]
        // case 229: return ["ContinueStatement"]
        // case 230: return ["BreakStatement"]
        // case 231: return ["ReturnStatement"]
        // case 232: return ["WithStatement"]
        // case 233: return ["SwitchStatement"]
        // case 234: return ["LabeledStatement"]
        // case 235: return ["ThrowStatement"]
        // case 236: return ["TryStatement"]
        // case 237: return ["DebuggerStatement"]
        // case 238: return ["VariableDeclaration"]
        // case 239: return ["VariableDeclarationList"]
        // case 240: return ["FunctionDeclaration"]
        // case 241: return ["ClassDeclaration"]
        // case 242: return ["InterfaceDeclaration"]
        // case 243: return ["TypeAliasDeclaration"]
        // case 244: return ["EnumDeclaration"]
        // case 245: return ["ModuleDeclaration"]
        // case 246: return ["ModuleBlock"]
        // case 247: return ["CaseBlock"]
        // case 248: return ["NamespaceExportDeclaration"]
        // case 249: return ["ImportEqualsDeclaration"]
        // case 250: return ["ImportDeclaration"]
        // case 251: return ["ImportClause"]
        // case 252: return ["NamespaceImport"]
        // case 253: return ["NamedImports"]
        // case 254: return ["ImportSpecifier"]
        // case 255: return ["ExportAssignment"]
        // case 256: return ["ExportDeclaration"]
        // case 257: return ["NamedExports"]
        // case 258: return ["ExportSpecifier"]
        // case 259: return ["MissingDeclaration"]
        // case 260: return ["ExternalModuleReference"]
        // case 261: return ["JsxElement"]
        // case 262: return ["JsxSelfClosingElement"]
        // case 263: return ["JsxOpeningElement"]
        // case 264: return ["JsxClosingElement"]
        // case 265: return ["JsxFragment"]
        // case 266: return ["JsxOpeningFragment"]
        // case 267: return ["JsxClosingFragment"]
        // case 268: return ["JsxAttribute"]
        // case 269: return ["JsxAttributes"]
        // case 270: return ["JsxSpreadAttribute"]
        // case 271: return ["JsxExpression"]
        // case 272: return ["CaseClause"]
        // case 273: return ["DefaultClause"]
        // case 274: return ["HeritageClause"]
        // case 275: return ["CatchClause"]
        // case 276: return ["PropertyAssignment"]
        // case 277: return ["ShorthandPropertyAssignment"]
        // case 278: return ["SpreadAssignment"]
        // case 279: return ["EnumMember"]
        // case 280: return ["UnparsedPrologue"]
        // case 281: return ["UnparsedPrepend"]
        case 282: return ["UnparsedText"]
        case 283: return ["UnparsedInternalText"]
        // case 284: return ["UnparsedSyntheticReference"]
        // case 285: return ["SourceFile"]
        // case 286: return ["Bundle"]
        // case 287: return ["UnparsedSource"]
        // case 288: return ["InputFiles"]
        // case 289: return ["JSDocTypeExpression"]
        // case 290: return ["JSDocAllType"]
        // case 291: return ["JSDocUnknownType"]
        // case 292: return ["JSDocNullableType"]
        // case 293: return ["JSDocNonNullableType"]
        // case 294: return ["JSDocOptionalType"]
        // case 295: return ["JSDocFunctionType"]
        // case 296: return ["JSDocVariadicType"]
        // case 297: return ["JSDocNamepathType"]
        case 298: return ["JSDocComment"]
        // case 299: return ["JSDocTypeLiteral"]
        // case 300: return ["JSDocSignature"]
        // case 301: return ["JSDocTag"]
        // case 302: return ["JSDocAugmentsTag"]
        // case 303: return ["JSDocAuthorTag"]
        // case 304: return ["JSDocClassTag"]
        // case 305: return ["JSDocCallbackTag"]
        // case 306: return ["JSDocEnumTag"]
        // case 307: return ["JSDocParameterTag"]
        // case 308: return ["JSDocReturnTag"]
        // case 309: return ["JSDocThisTag"]
        // case 310: return ["JSDocTypeTag"]
        // case 311: return ["JSDocTemplateTag"]
        // case 312: return ["JSDocTypedefTag"]
        // case 313: return ["JSDocPropertyTag"]
        // case 314: return ["SyntaxList"]
        // case 315: return ["NotEmittedStatement"]
        // case 316: return ["PartiallyEmittedExpression"]
        // case 317: return ["CommaListExpression"]
        case 318: return ["MergeDeclarationMarker"]
        case 319: return ["EndOfDeclarationMarker"]
        case 320: return ["Count"]
        default: return null
    }
}

