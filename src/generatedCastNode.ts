import * as ts from "typescript"

export type GeneratedTypedNode =
    // | [ "Unknown", ts.Unknown ]
    | ["EndOfFileToken", ts.EndOfFileToken]
    // | [ "SingleLineCommentTrivia", ts.SingleLineCommentTrivia ]
    // | [ "MultiLineCommentTrivia", ts.MultiLineCommentTrivia ]
    // | [ "NewLineTrivia", ts.NewLineTrivia ]
    // | [ "WhitespaceTrivia", ts.WhitespaceTrivia ]
    // | [ "ShebangTrivia", ts.ShebangTrivia ]
    // | [ "ConflictMarkerTrivia", ts.ConflictMarkerTrivia ]
    | ["NumericLiteral", ts.NumericLiteral]
    //| ["BigIntLiteral", ts.BigIntLiteral]
    | ["StringLiteral", ts.StringLiteral]
    | ["JsxText", ts.JsxText]
    // | [ "JsxTextAllWhiteSpaces", ts.JsxTextAllWhiteSpaces ]
    | ["RegularExpressionLiteral", ts.RegularExpressionLiteral]
    | ["NoSubstitutionTemplateLiteral", ts.NoSubstitutionTemplateLiteral]
    | ["TemplateHead", ts.TemplateHead]
    | ["TemplateMiddle", ts.TemplateMiddle]
    | ["TemplateTail", ts.TemplateTail]
    // | [ "OpenBraceToken", ts.OpenBraceToken ]
    // | [ "CloseBraceToken", ts.CloseBraceToken ]
    // | [ "OpenParenToken", ts.OpenParenToken ]
    // | [ "CloseParenToken", ts.CloseParenToken ]
    // | [ "OpenBracketToken", ts.OpenBracketToken ]
    // | [ "CloseBracketToken", ts.CloseBracketToken ]
    // | [ "DotToken", ts.DotToken ]
    | ["DotDotDotToken", ts.DotDotDotToken]
    // | [ "SemicolonToken", ts.SemicolonToken ]
    // | [ "CommaToken", ts.CommaToken ]
    // | [ "LessThanToken", ts.LessThanToken ]
    // | [ "LessThanSlashToken", ts.LessThanSlashToken ]
    // | [ "GreaterThanToken", ts.GreaterThanToken ]
    // | [ "LessThanEqualsToken", ts.LessThanEqualsToken ]
    // | [ "GreaterThanEqualsToken", ts.GreaterThanEqualsToken ]
    // | [ "EqualsEqualsToken", ts.EqualsEqualsToken ]
    // | [ "ExclamationEqualsToken", ts.ExclamationEqualsToken ]
    // | [ "EqualsEqualsEqualsToken", ts.EqualsEqualsEqualsToken ]
    // | [ "ExclamationEqualsEqualsToken", ts.ExclamationEqualsEqualsToken ]
    | ["EqualsGreaterThanToken", ts.EqualsGreaterThanToken]
    | ["PlusToken", ts.PlusToken]
    | ["MinusToken", ts.MinusToken]
    | ["AsteriskToken", ts.AsteriskToken]
    // | [ "AsteriskAsteriskToken", ts.AsteriskAsteriskToken ]
    // | [ "SlashToken", ts.SlashToken ]
    // | [ "PercentToken", ts.PercentToken ]
    // | [ "PlusPlusToken", ts.PlusPlusToken ]
    // | [ "MinusMinusToken", ts.MinusMinusToken ]
    // | [ "LessThanLessThanToken", ts.LessThanLessThanToken ]
    // | [ "GreaterThanGreaterThanToken", ts.GreaterThanGreaterThanToken ]
    // | [ "GreaterThanGreaterThanGreaterThanToken", ts.GreaterThanGreaterThanGreaterThanToken ]
    // | [ "AmpersandToken", ts.AmpersandToken ]
    // | [ "BarToken", ts.BarToken ]
    // | [ "CaretToken", ts.CaretToken ]
    | ["ExclamationToken", ts.ExclamationToken]
    // | [ "TildeToken", ts.TildeToken ]
    // | [ "AmpersandAmpersandToken", ts.AmpersandAmpersandToken ]
    // | [ "BarBarToken", ts.BarBarToken ]
    | ["QuestionToken", ts.QuestionToken]
    | ["ColonToken", ts.ColonToken]
    // | [ "AtToken", ts.AtToken ]
    /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
    // | [ "BacktickToken", ts.BacktickToken ]
    | ["EqualsToken", ts.EqualsToken]
    // | [ "PlusEqualsToken", ts.PlusEqualsToken ]
    // | [ "MinusEqualsToken", ts.MinusEqualsToken ]
    // | [ "AsteriskEqualsToken", ts.AsteriskEqualsToken ]
    // | [ "AsteriskAsteriskEqualsToken", ts.AsteriskAsteriskEqualsToken ]
    // | [ "SlashEqualsToken", ts.SlashEqualsToken ]
    // | [ "PercentEqualsToken", ts.PercentEqualsToken ]
    // | [ "LessThanLessThanEqualsToken", ts.LessThanLessThanEqualsToken ]
    // | [ "GreaterThanGreaterThanEqualsToken", ts.GreaterThanGreaterThanEqualsToken ]
    // | [ "GreaterThanGreaterThanGreaterThanEqualsToken", ts.GreaterThanGreaterThanGreaterThanEqualsToken ]
    // | [ "AmpersandEqualsToken", ts.AmpersandEqualsToken ]
    // | [ "BarEqualsToken", ts.BarEqualsToken ]
    // | [ "CaretEqualsToken", ts.CaretEqualsToken ]
    | ["Identifier", ts.Identifier]
    // | [ "BreakKeyword", ts.BreakKeyword ]
    // | [ "CaseKeyword", ts.CaseKeyword ]
    // | [ "CatchKeyword", ts.CatchKeyword ]
    // | [ "ClassKeyword", ts.ClassKeyword ]
    // | [ "ConstKeyword", ts.ConstKeyword ]
    // | [ "ContinueKeyword", ts.ContinueKeyword ]
    // | [ "DebuggerKeyword", ts.DebuggerKeyword ]
    // | [ "DefaultKeyword", ts.DefaultKeyword ]
    // | [ "DeleteKeyword", ts.DeleteKeyword ]
    // | [ "DoKeyword", ts.DoKeyword ]
    // | [ "ElseKeyword", ts.ElseKeyword ]
    // | [ "EnumKeyword", ts.EnumKeyword ]
    // | [ "ExportKeyword", ts.ExportKeyword ]
    // | [ "ExtendsKeyword", ts.ExtendsKeyword ]
    // | [ "FalseKeyword", ts.FalseKeyword ]
    // | [ "FinallyKeyword", ts.FinallyKeyword ]
    // | [ "ForKeyword", ts.ForKeyword ]
    // | [ "FunctionKeyword", ts.FunctionKeyword ]
    // | [ "IfKeyword", ts.IfKeyword ]
    // | [ "ImportKeyword", ts.ImportKeyword ]
    // | [ "InKeyword", ts.InKeyword ]
    // | [ "InstanceOfKeyword", ts.InstanceOfKeyword ]
    // | [ "NewKeyword", ts.NewKeyword ]
    // | [ "NullKeyword", ts.NullKeyword ]
    // | [ "ReturnKeyword", ts.ReturnKeyword ]
    // | [ "SuperKeyword", ts.SuperKeyword ]
    // | [ "SwitchKeyword", ts.SwitchKeyword ]
    // | [ "ThisKeyword", ts.ThisKeyword ]
    // | [ "ThrowKeyword", ts.ThrowKeyword ]
    // | [ "TrueKeyword", ts.TrueKeyword ]
    // | [ "TryKeyword", ts.TryKeyword ]
    // | [ "TypeOfKeyword", ts.TypeOfKeyword ]
    // | [ "VarKeyword", ts.VarKeyword ]
    // | [ "VoidKeyword", ts.VoidKeyword ]
    // | [ "WhileKeyword", ts.WhileKeyword ]
    // | [ "WithKeyword", ts.WithKeyword ]
    // | [ "ImplementsKeyword", ts.ImplementsKeyword ]
    // | [ "InterfaceKeyword", ts.InterfaceKeyword ]
    // | [ "LetKeyword", ts.LetKeyword ]
    // | [ "PackageKeyword", ts.PackageKeyword ]
    // | [ "PrivateKeyword", ts.PrivateKeyword ]
    // | [ "ProtectedKeyword", ts.ProtectedKeyword ]
    // | [ "PublicKeyword", ts.PublicKeyword ]
    // | [ "StaticKeyword", ts.StaticKeyword ]
    // | [ "YieldKeyword", ts.YieldKeyword ]
    // | [ "AbstractKeyword", ts.AbstractKeyword ]
    // | [ "AsKeyword", ts.AsKeyword ]
    // | [ "AnyKeyword", ts.AnyKeyword ]
    // | [ "AsyncKeyword", ts.AsyncKeyword ]
    // | [ "AwaitKeyword", ts.AwaitKeyword ]
    // | [ "BooleanKeyword", ts.BooleanKeyword ]
    // | [ "ConstructorKeyword", ts.ConstructorKeyword ]
    // | [ "DeclareKeyword", ts.DeclareKeyword ]
    // | [ "GetKeyword", ts.GetKeyword ]
    // | [ "InferKeyword", ts.InferKeyword ]
    // | [ "IsKeyword", ts.IsKeyword ]
    // | [ "KeyOfKeyword", ts.KeyOfKeyword ]
    // | [ "ModuleKeyword", ts.ModuleKeyword ]
    // | [ "NamespaceKeyword", ts.NamespaceKeyword ]
    // | [ "NeverKeyword", ts.NeverKeyword ]
    // | [ "ReadonlyKeyword", ts.ReadonlyKeyword ]
    // | [ "RequireKeyword", ts.RequireKeyword ]
    // | [ "NumberKeyword", ts.NumberKeyword ]
    // | [ "ObjectKeyword", ts.ObjectKeyword ]
    // | [ "SetKeyword", ts.SetKeyword ]
    // | [ "StringKeyword", ts.StringKeyword ]
    // | [ "SymbolKeyword", ts.SymbolKeyword ]
    // | [ "TypeKeyword", ts.TypeKeyword ]
    // | [ "UndefinedKeyword", ts.UndefinedKeyword ]
    // | [ "UniqueKeyword", ts.UniqueKeyword ]
    // | [ "UnknownKeyword", ts.UnknownKeyword ]
    // | [ "FromKeyword", ts.FromKeyword ]
    // | [ "GlobalKeyword", ts.GlobalKeyword ]
    // | [ "BigIntKeyword", ts.BigIntKeyword ]
    // | [ "OfKeyword", ts.OfKeyword ]
    | ["QualifiedName", ts.QualifiedName]
    | ["ComputedPropertyName", ts.ComputedPropertyName]
    //| ["TypeParameter", ts.TypeParameter]
    // | [ "Parameter", ts.Parameter ]
    | ["Decorator", ts.Decorator]
    | ["PropertySignature", ts.PropertySignature]
    | ["PropertyDeclaration", ts.PropertyDeclaration]
    | ["MethodSignature", ts.MethodSignature]
    | ["MethodDeclaration", ts.MethodDeclaration]
    // | [ "Constructor", ts.Constructor ]
    // | [ "GetAccessor", ts.GetAccessor ]
    // | [ "SetAccessor", ts.SetAccessor ]
    // | [ "CallSignature", ts.CallSignature ]
    // | [ "ConstructSignature", ts.ConstructSignature ]
    // | [ "IndexSignature", ts.IndexSignature ]
    // | ["TypePredicate", ts.TypePredicate]
    // | ["TypeReference", ts.TypeReference]
    // | [ "FunctionType", ts.FunctionType ]
    // | [ "ConstructorType", ts.ConstructorType ]
    // | [ "TypeQuery", ts.TypeQuery ]
    // | [ "TypeLiteral", ts.TypeLiteral ]
    // | [ "ArrayType", ts.ArrayType ]
    // | ["TupleType", ts.TupleType]
    // | [ "OptionalType", ts.OptionalType ]
    // | [ "RestType", ts.RestType ]
    // | ["UnionType", ts.UnionType]
    // | ["IntersectionType", ts.IntersectionType]
    // | ["ConditionalType", ts.ConditionalType]
    // | [ "InferType", ts.InferType ]
    // | [ "ParenthesizedType", ts.ParenthesizedType ]
    // | [ "ThisType", ts.ThisType ]
    // | [ "TypeOperator", ts.TypeOperator ]
    // | ["IndexedAccessType", ts.IndexedAccessType]
    // | [ "MappedType", ts.MappedType ]
    // | ["LiteralType", ts.LiteralType]
    // | [ "ImportType", ts.ImportType ]
    | ["ObjectBindingPattern", ts.ObjectBindingPattern]
    | ["ArrayBindingPattern", ts.ArrayBindingPattern]
    | ["BindingElement", ts.BindingElement]
    | ["ArrayLiteralExpression", ts.ArrayLiteralExpression]
    | ["ObjectLiteralExpression", ts.ObjectLiteralExpression]
    | ["PropertyAccessExpression", ts.PropertyAccessExpression]
    | ["ElementAccessExpression", ts.ElementAccessExpression]
    | ["CallExpression", ts.CallExpression]
    | ["NewExpression", ts.NewExpression]
    | ["TaggedTemplateExpression", ts.TaggedTemplateExpression]
    // | [ "TypeAssertionExpression", ts.TypeAssertionExpression ]
    | ["ParenthesizedExpression", ts.ParenthesizedExpression]
    | ["FunctionExpression", ts.FunctionExpression]
    | ["ArrowFunction", ts.ArrowFunction]
    | ["DeleteExpression", ts.DeleteExpression]
    | ["TypeOfExpression", ts.TypeOfExpression]
    | ["VoidExpression", ts.VoidExpression]
    | ["AwaitExpression", ts.AwaitExpression]
    | ["PrefixUnaryExpression", ts.PrefixUnaryExpression]
    | ["PostfixUnaryExpression", ts.PostfixUnaryExpression]
    | ["BinaryExpression", ts.BinaryExpression]
    | ["ConditionalExpression", ts.ConditionalExpression]
    | ["TemplateExpression", ts.TemplateExpression]
    | ["YieldExpression", ts.YieldExpression]
    | ["SpreadElement", ts.SpreadElement]
    | ["ClassExpression", ts.ClassExpression]
    | ["OmittedExpression", ts.OmittedExpression]
    | ["ExpressionWithTypeArguments", ts.ExpressionWithTypeArguments]
    | ["AsExpression", ts.AsExpression]
    | ["NonNullExpression", ts.NonNullExpression]
    | ["MetaProperty", ts.MetaProperty]
    //| ["SyntheticExpression", ts.SyntheticExpression]
    | ["TemplateSpan", ts.TemplateSpan]
    | ["SemicolonClassElement", ts.SemicolonClassElement]
    | ["Block", ts.Block]
    | ["VariableStatement", ts.VariableStatement]
    | ["EmptyStatement", ts.EmptyStatement]
    | ["ExpressionStatement", ts.ExpressionStatement]
    | ["IfStatement", ts.IfStatement]
    | ["DoStatement", ts.DoStatement]
    | ["WhileStatement", ts.WhileStatement]
    | ["ForStatement", ts.ForStatement]
    | ["ForInStatement", ts.ForInStatement]
    | ["ForOfStatement", ts.ForOfStatement]
    | ["ContinueStatement", ts.ContinueStatement]
    | ["BreakStatement", ts.BreakStatement]
    | ["ReturnStatement", ts.ReturnStatement]
    | ["WithStatement", ts.WithStatement]
    | ["SwitchStatement", ts.SwitchStatement]
    | ["LabeledStatement", ts.LabeledStatement]
    | ["ThrowStatement", ts.ThrowStatement]
    | ["TryStatement", ts.TryStatement]
    | ["DebuggerStatement", ts.DebuggerStatement]
    | ["VariableDeclaration", ts.VariableDeclaration]
    | ["VariableDeclarationList", ts.VariableDeclarationList]
    | ["FunctionDeclaration", ts.FunctionDeclaration]
    | ["ClassDeclaration", ts.ClassDeclaration]
    | ["InterfaceDeclaration", ts.InterfaceDeclaration]
    | ["TypeAliasDeclaration", ts.TypeAliasDeclaration]
    | ["EnumDeclaration", ts.EnumDeclaration]
    | ["ModuleDeclaration", ts.ModuleDeclaration]
    | ["ModuleBlock", ts.ModuleBlock]
    | ["CaseBlock", ts.CaseBlock]
    | ["NamespaceExportDeclaration", ts.NamespaceExportDeclaration]
    | ["ImportEqualsDeclaration", ts.ImportEqualsDeclaration]
    | ["ImportDeclaration", ts.ImportDeclaration]
    | ["ImportClause", ts.ImportClause]
    | ["NamespaceImport", ts.NamespaceImport]
    | ["NamedImports", ts.NamedImports]
    | ["ImportSpecifier", ts.ImportSpecifier]
    | ["ExportAssignment", ts.ExportAssignment]
    | ["ExportDeclaration", ts.ExportDeclaration]
    | ["NamedExports", ts.NamedExports]
    | ["ExportSpecifier", ts.ExportSpecifier]
    | ["MissingDeclaration", ts.MissingDeclaration]
    | ["ExternalModuleReference", ts.ExternalModuleReference]
    | ["JsxElement", ts.JsxElement]
    | ["JsxSelfClosingElement", ts.JsxSelfClosingElement]
    | ["JsxOpeningElement", ts.JsxOpeningElement]
    | ["JsxClosingElement", ts.JsxClosingElement]
    | ["JsxFragment", ts.JsxFragment]
    | ["JsxOpeningFragment", ts.JsxOpeningFragment]
    | ["JsxClosingFragment", ts.JsxClosingFragment]
    | ["JsxAttribute", ts.JsxAttribute]
    | ["JsxAttributes", ts.JsxAttributes]
    | ["JsxSpreadAttribute", ts.JsxSpreadAttribute]
    | ["JsxExpression", ts.JsxExpression]
    | ["CaseClause", ts.CaseClause]
    | ["DefaultClause", ts.DefaultClause]
    | ["HeritageClause", ts.HeritageClause]
    | ["CatchClause", ts.CatchClause]
    | ["PropertyAssignment", ts.PropertyAssignment]
    | ["ShorthandPropertyAssignment", ts.ShorthandPropertyAssignment]
    | ["SpreadAssignment", ts.SpreadAssignment]
    | ["EnumMember", ts.EnumMember]
    //| ["UnparsedPrologue", ts.UnparsedPrologue]
    //| ["UnparsedPrepend", ts.UnparsedPrepend]
    // | [ "UnparsedText", ts.UnparsedText ]
    // | [ "UnparsedInternalText", ts.UnparsedInternalText ]
    //| ["UnparsedSyntheticReference", ts.UnparsedSyntheticReference]
    | ["SourceFile", ts.SourceFile]
    | ["Bundle", ts.Bundle]
    | ["UnparsedSource", ts.UnparsedSource]
    | ["InputFiles", ts.InputFiles]
    | ["JSDocTypeExpression", ts.JSDocTypeExpression]
    | ["JSDocAllType", ts.JSDocAllType]
    | ["JSDocUnknownType", ts.JSDocUnknownType]
    | ["JSDocNullableType", ts.JSDocNullableType]
    | ["JSDocNonNullableType", ts.JSDocNonNullableType]
    | ["JSDocOptionalType", ts.JSDocOptionalType]
    | ["JSDocFunctionType", ts.JSDocFunctionType]
    | ["JSDocVariadicType", ts.JSDocVariadicType]
    //| ["JSDocNamepathType", ts.JSDocNamepathType]
    // | [ "JSDocComment", ts.JSDocComment ]
    | ["JSDocTypeLiteral", ts.JSDocTypeLiteral]
    | ["JSDocSignature", ts.JSDocSignature]
    | ["JSDocTag", ts.JSDocTag]
    | ["JSDocAugmentsTag", ts.JSDocAugmentsTag]
    // | ["JSDocAuthorTag", ts.JSDocAuthorTag]
    | ["JSDocClassTag", ts.JSDocClassTag]
    | ["JSDocCallbackTag", ts.JSDocCallbackTag]
    // | ["JSDocEnumTag", ts.JSDocEnumTag]
    | ["JSDocParameterTag", ts.JSDocParameterTag]
    | ["JSDocReturnTag", ts.JSDocReturnTag]
    // | ["JSDocThisTag", ts.JSDocThisTag]
    | ["JSDocTypeTag", ts.JSDocTypeTag]
    | ["JSDocTemplateTag", ts.JSDocTemplateTag]
    | ["JSDocTypedefTag", ts.JSDocTypedefTag]
    | ["JSDocPropertyTag", ts.JSDocPropertyTag]
    | ["SyntaxList", ts.SyntaxList]
    | ["NotEmittedStatement", ts.NotEmittedStatement]
    | ["PartiallyEmittedExpression", ts.PartiallyEmittedExpression]
    | ["CommaListExpression", ts.CommaListExpression]
// | [ "MergeDeclarationMarker", ts.MergeDeclarationMarker ]
// | [ "EndOfDeclarationMarker", ts.EndOfDeclarationMarker ]
// | [ "Count", ts.Count ]


export function castNode(node: ts.Node): GeneratedTypedNode | null {
    switch (node.kind) {
        // case ts.SyntaxKind.Unknown: return ["Unknown", node as ts.Unknown]
        //case ts.SyntaxKind.EndOfFileToken: return ["EndOfFileToken", node as ts.EndOfFileToken]
        // case ts.SyntaxKind.SingleLineCommentTrivia: return ["SingleLineCommentTrivia", node as ts.SingleLineCommentTrivia]
        // case ts.SyntaxKind.MultiLineCommentTrivia: return ["MultiLineCommentTrivia", node as ts.MultiLineCommentTrivia]
        // case ts.SyntaxKind.NewLineTrivia: return ["NewLineTrivia", node as ts.NewLineTrivia]
        // case ts.SyntaxKind.WhitespaceTrivia: return ["WhitespaceTrivia", node as ts.WhitespaceTrivia]
        // case ts.SyntaxKind.ShebangTrivia: return ["ShebangTrivia", node as ts.ShebangTrivia]
        // case ts.SyntaxKind.ConflictMarkerTrivia: return ["ConflictMarkerTrivia", node as ts.ConflictMarkerTrivia]
        case ts.SyntaxKind.NumericLiteral: return ["NumericLiteral", node as ts.NumericLiteral]
        // case ts.SyntaxKind.BigIntLiteral: return ["BigIntLiteral", node as ts.BigIntLiteral]
        case ts.SyntaxKind.StringLiteral: return ["StringLiteral", node as ts.StringLiteral]
        case ts.SyntaxKind.JsxText: return ["JsxText", node as ts.JsxText]
        // case ts.SyntaxKind.JsxTextAllWhiteSpaces: return ["JsxTextAllWhiteSpaces", node as ts.JsxTextAllWhiteSpaces]
        case ts.SyntaxKind.RegularExpressionLiteral: return ["RegularExpressionLiteral", node as ts.RegularExpressionLiteral]
        case ts.SyntaxKind.NoSubstitutionTemplateLiteral: return ["NoSubstitutionTemplateLiteral", node as ts.NoSubstitutionTemplateLiteral]
        case ts.SyntaxKind.TemplateHead: return ["TemplateHead", node as ts.TemplateHead]
        case ts.SyntaxKind.TemplateMiddle: return ["TemplateMiddle", node as ts.TemplateMiddle]
        case ts.SyntaxKind.TemplateTail: return ["TemplateTail", node as ts.TemplateTail]
        // case ts.SyntaxKind.OpenBraceToken: return ["OpenBraceToken", node as ts.OpenBraceToken]
        // case ts.SyntaxKind.CloseBraceToken: return ["CloseBraceToken", node as ts.CloseBraceToken]
        // case ts.SyntaxKind.OpenParenToken: return ["OpenParenToken", node as ts.OpenParenToken]
        // case ts.SyntaxKind.CloseParenToken: return ["CloseParenToken", node as ts.CloseParenToken]
        // case ts.SyntaxKind.OpenBracketToken: return ["OpenBracketToken", node as ts.OpenBracketToken]
        // case ts.SyntaxKind.CloseBracketToken: return ["CloseBracketToken", node as ts.CloseBracketToken]
        // case ts.SyntaxKind.DotToken: return ["DotToken", node as ts.DotToken]
        case ts.SyntaxKind.DotDotDotToken: return ["DotDotDotToken", node as ts.DotDotDotToken]
        // case ts.SyntaxKind.SemicolonToken: return ["SemicolonToken", node as ts.SemicolonToken]
        // case ts.SyntaxKind.CommaToken: return ["CommaToken", node as ts.CommaToken]
        // case ts.SyntaxKind.LessThanToken: return ["LessThanToken", node as ts.LessThanToken]
        // case ts.SyntaxKind.LessThanSlashToken: return ["LessThanSlashToken", node as ts.LessThanSlashToken]
        // case ts.SyntaxKind.GreaterThanToken: return ["GreaterThanToken", node as ts.GreaterThanToken]
        // case ts.SyntaxKind.LessThanEqualsToken: return ["LessThanEqualsToken", node as ts.LessThanEqualsToken]
        // case ts.SyntaxKind.GreaterThanEqualsToken: return ["GreaterThanEqualsToken", node as ts.GreaterThanEqualsToken]
        // case ts.SyntaxKind.EqualsEqualsToken: return ["EqualsEqualsToken", node as ts.EqualsEqualsToken]
        // case ts.SyntaxKind.ExclamationEqualsToken: return ["ExclamationEqualsToken", node as ts.ExclamationEqualsToken]
        // case ts.SyntaxKind.EqualsEqualsEqualsToken: return ["EqualsEqualsEqualsToken", node as ts.EqualsEqualsEqualsToken]
        // case ts.SyntaxKind.ExclamationEqualsEqualsToken: return ["ExclamationEqualsEqualsToken", node as ts.ExclamationEqualsEqualsToken]
        case ts.SyntaxKind.EqualsGreaterThanToken: return ["EqualsGreaterThanToken", node as ts.EqualsGreaterThanToken]
        case ts.SyntaxKind.PlusToken: return ["PlusToken", node as ts.PlusToken]
        case ts.SyntaxKind.MinusToken: return ["MinusToken", node as ts.MinusToken]
        case ts.SyntaxKind.AsteriskToken: return ["AsteriskToken", node as ts.AsteriskToken]
        // case ts.SyntaxKind.AsteriskAsteriskToken: return ["AsteriskAsteriskToken", node as ts.AsteriskAsteriskToken]
        // case ts.SyntaxKind.SlashToken: return ["SlashToken", node as ts.SlashToken]
        // case ts.SyntaxKind.PercentToken: return ["PercentToken", node as ts.PercentToken]
        // case ts.SyntaxKind.PlusPlusToken: return ["PlusPlusToken", node as ts.PlusPlusToken]
        // case ts.SyntaxKind.MinusMinusToken: return ["MinusMinusToken", node as ts.MinusMinusToken]
        // case ts.SyntaxKind.LessThanLessThanToken: return ["LessThanLessThanToken", node as ts.LessThanLessThanToken]
        // case ts.SyntaxKind.GreaterThanGreaterThanToken: return ["GreaterThanGreaterThanToken", node as ts.GreaterThanGreaterThanToken]
        // case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken: return ["GreaterThanGreaterThanGreaterThanToken", node as ts.GreaterThanGreaterThanGreaterThanToken]
        // case ts.SyntaxKind.AmpersandToken: return ["AmpersandToken", node as ts.AmpersandToken]
        // case ts.SyntaxKind.BarToken: return ["BarToken", node as ts.BarToken]
        // case ts.SyntaxKind.CaretToken: return ["CaretToken", node as ts.CaretToken]
        case ts.SyntaxKind.ExclamationToken: return ["ExclamationToken", node as ts.ExclamationToken]
        // case ts.SyntaxKind.TildeToken: return ["TildeToken", node as ts.TildeToken]
        // case ts.SyntaxKind.AmpersandAmpersandToken: return ["AmpersandAmpersandToken", node as ts.AmpersandAmpersandToken]
        // case ts.SyntaxKind.BarBarToken: return ["BarBarToken", node as ts.BarBarToken]
        case ts.SyntaxKind.QuestionToken: return ["QuestionToken", node as ts.QuestionToken]
        case ts.SyntaxKind.ColonToken: return ["ColonToken", node as ts.ColonToken]
        // case ts.SyntaxKind.AtToken: return ["AtToken", node as ts.AtToken]
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        // case ts.SyntaxKind.BacktickToken: return ["BacktickToken", node as ts.BacktickToken]
        case ts.SyntaxKind.EqualsToken: return ["EqualsToken", node as ts.EqualsToken]
        // case ts.SyntaxKind.PlusEqualsToken: return ["PlusEqualsToken", node as ts.PlusEqualsToken]
        // case ts.SyntaxKind.MinusEqualsToken: return ["MinusEqualsToken", node as ts.MinusEqualsToken]
        // case ts.SyntaxKind.AsteriskEqualsToken: return ["AsteriskEqualsToken", node as ts.AsteriskEqualsToken]
        // case ts.SyntaxKind.AsteriskAsteriskEqualsToken: return ["AsteriskAsteriskEqualsToken", node as ts.AsteriskAsteriskEqualsToken]
        // case ts.SyntaxKind.SlashEqualsToken: return ["SlashEqualsToken", node as ts.SlashEqualsToken]
        // case ts.SyntaxKind.PercentEqualsToken: return ["PercentEqualsToken", node as ts.PercentEqualsToken]
        // case ts.SyntaxKind.LessThanLessThanEqualsToken: return ["LessThanLessThanEqualsToken", node as ts.LessThanLessThanEqualsToken]
        // case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken: return ["GreaterThanGreaterThanEqualsToken", node as ts.GreaterThanGreaterThanEqualsToken]
        // case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken: return ["GreaterThanGreaterThanGreaterThanEqualsToken", node as ts.GreaterThanGreaterThanGreaterThanEqualsToken]
        // case ts.SyntaxKind.AmpersandEqualsToken: return ["AmpersandEqualsToken", node as ts.AmpersandEqualsToken]
        // case ts.SyntaxKind.BarEqualsToken: return ["BarEqualsToken", node as ts.BarEqualsToken]
        // case ts.SyntaxKind.CaretEqualsToken: return ["CaretEqualsToken", node as ts.CaretEqualsToken]
        case ts.SyntaxKind.Identifier: return ["Identifier", node as ts.Identifier]
        // case ts.SyntaxKind.BreakKeyword: return ["BreakKeyword", node as ts.BreakKeyword]
        // case ts.SyntaxKind.CaseKeyword: return ["CaseKeyword", node as ts.CaseKeyword]
        // case ts.SyntaxKind.CatchKeyword: return ["CatchKeyword", node as ts.CatchKeyword]
        // case ts.SyntaxKind.ClassKeyword: return ["ClassKeyword", node as ts.ClassKeyword]
        // case ts.SyntaxKind.ConstKeyword: return ["ConstKeyword", node as ts.ConstKeyword]
        // case ts.SyntaxKind.ContinueKeyword: return ["ContinueKeyword", node as ts.ContinueKeyword]
        // case ts.SyntaxKind.DebuggerKeyword: return ["DebuggerKeyword", node as ts.DebuggerKeyword]
        // case ts.SyntaxKind.DefaultKeyword: return ["DefaultKeyword", node as ts.DefaultKeyword]
        // case ts.SyntaxKind.DeleteKeyword: return ["DeleteKeyword", node as ts.DeleteKeyword]
        // case ts.SyntaxKind.DoKeyword: return ["DoKeyword", node as ts.DoKeyword]
        // case ts.SyntaxKind.ElseKeyword: return ["ElseKeyword", node as ts.ElseKeyword]
        // case ts.SyntaxKind.EnumKeyword: return ["EnumKeyword", node as ts.EnumKeyword]
        // case ts.SyntaxKind.ExportKeyword: return ["ExportKeyword", node as ts.ExportKeyword]
        // case ts.SyntaxKind.ExtendsKeyword: return ["ExtendsKeyword", node as ts.ExtendsKeyword]
        // case ts.SyntaxKind.FalseKeyword: return ["FalseKeyword", node as ts.FalseKeyword]
        // case ts.SyntaxKind.FinallyKeyword: return ["FinallyKeyword", node as ts.FinallyKeyword]
        // case ts.SyntaxKind.ForKeyword: return ["ForKeyword", node as ts.ForKeyword]
        // case ts.SyntaxKind.FunctionKeyword: return ["FunctionKeyword", node as ts.FunctionKeyword]
        // case ts.SyntaxKind.IfKeyword: return ["IfKeyword", node as ts.IfKeyword]
        // case ts.SyntaxKind.ImportKeyword: return ["ImportKeyword", node as ts.ImportKeyword]
        // case ts.SyntaxKind.InKeyword: return ["InKeyword", node as ts.InKeyword]
        // case ts.SyntaxKind.InstanceOfKeyword: return ["InstanceOfKeyword", node as ts.InstanceOfKeyword]
        // case ts.SyntaxKind.NewKeyword: return ["NewKeyword", node as ts.NewKeyword]
        // case ts.SyntaxKind.NullKeyword: return ["NullKeyword", node as ts.NullKeyword]
        // case ts.SyntaxKind.ReturnKeyword: return ["ReturnKeyword", node as ts.ReturnKeyword]
        // case ts.SyntaxKind.SuperKeyword: return ["SuperKeyword", node as ts.SuperKeyword]
        // case ts.SyntaxKind.SwitchKeyword: return ["SwitchKeyword", node as ts.SwitchKeyword]
        // case ts.SyntaxKind.ThisKeyword: return ["ThisKeyword", node as ts.ThisKeyword]
        // case ts.SyntaxKind.ThrowKeyword: return ["ThrowKeyword", node as ts.ThrowKeyword]
        // case ts.SyntaxKind.TrueKeyword: return ["TrueKeyword", node as ts.TrueKeyword]
        // case ts.SyntaxKind.TryKeyword: return ["TryKeyword", node as ts.TryKeyword]
        // case ts.SyntaxKind.TypeOfKeyword: return ["TypeOfKeyword", node as ts.TypeOfKeyword]
        // case ts.SyntaxKind.VarKeyword: return ["VarKeyword", node as ts.VarKeyword]
        // case ts.SyntaxKind.VoidKeyword: return ["VoidKeyword", node as ts.VoidKeyword]
        // case ts.SyntaxKind.WhileKeyword: return ["WhileKeyword", node as ts.WhileKeyword]
        // case ts.SyntaxKind.WithKeyword: return ["WithKeyword", node as ts.WithKeyword]
        // case ts.SyntaxKind.ImplementsKeyword: return ["ImplementsKeyword", node as ts.ImplementsKeyword]
        // case ts.SyntaxKind.InterfaceKeyword: return ["InterfaceKeyword", node as ts.InterfaceKeyword]
        // case ts.SyntaxKind.LetKeyword: return ["LetKeyword", node as ts.LetKeyword]
        // case ts.SyntaxKind.PackageKeyword: return ["PackageKeyword", node as ts.PackageKeyword]
        // case ts.SyntaxKind.PrivateKeyword: return ["PrivateKeyword", node as ts.PrivateKeyword]
        // case ts.SyntaxKind.ProtectedKeyword: return ["ProtectedKeyword", node as ts.ProtectedKeyword]
        // case ts.SyntaxKind.PublicKeyword: return ["PublicKeyword", node as ts.PublicKeyword]
        // case ts.SyntaxKind.StaticKeyword: return ["StaticKeyword", node as ts.StaticKeyword]
        // case ts.SyntaxKind.YieldKeyword: return ["YieldKeyword", node as ts.YieldKeyword]
        // case ts.SyntaxKind.AbstractKeyword: return ["AbstractKeyword", node as ts.AbstractKeyword]
        // case ts.SyntaxKind.AsKeyword: return ["AsKeyword", node as ts.AsKeyword]
        // case ts.SyntaxKind.AnyKeyword: return ["AnyKeyword", node as ts.AnyKeyword]
        // case ts.SyntaxKind.AsyncKeyword: return ["AsyncKeyword", node as ts.AsyncKeyword]
        // case ts.SyntaxKind.AwaitKeyword: return ["AwaitKeyword", node as ts.AwaitKeyword]
        // case ts.SyntaxKind.BooleanKeyword: return ["BooleanKeyword", node as ts.BooleanKeyword]
        // case ts.SyntaxKind.ConstructorKeyword: return ["ConstructorKeyword", node as ts.ConstructorKeyword]
        // case ts.SyntaxKind.DeclareKeyword: return ["DeclareKeyword", node as ts.DeclareKeyword]
        // case ts.SyntaxKind.GetKeyword: return ["GetKeyword", node as ts.GetKeyword]
        // case ts.SyntaxKind.InferKeyword: return ["InferKeyword", node as ts.InferKeyword]
        // case ts.SyntaxKind.IsKeyword: return ["IsKeyword", node as ts.IsKeyword]
        // case ts.SyntaxKind.KeyOfKeyword: return ["KeyOfKeyword", node as ts.KeyOfKeyword]
        // case ts.SyntaxKind.ModuleKeyword: return ["ModuleKeyword", node as ts.ModuleKeyword]
        // case ts.SyntaxKind.NamespaceKeyword: return ["NamespaceKeyword", node as ts.NamespaceKeyword]
        // case ts.SyntaxKind.NeverKeyword: return ["NeverKeyword", node as ts.NeverKeyword]
        // case ts.SyntaxKind.ReadonlyKeyword: return ["ReadonlyKeyword", node as ts.ReadonlyKeyword]
        // case ts.SyntaxKind.RequireKeyword: return ["RequireKeyword", node as ts.RequireKeyword]
        // case ts.SyntaxKind.NumberKeyword: return ["NumberKeyword", node as ts.NumberKeyword]
        // case ts.SyntaxKind.ObjectKeyword: return ["ObjectKeyword", node as ts.ObjectKeyword]
        // case ts.SyntaxKind.SetKeyword: return ["SetKeyword", node as ts.SetKeyword]
        // case ts.SyntaxKind.StringKeyword: return ["StringKeyword", node as ts.StringKeyword]
        // case ts.SyntaxKind.SymbolKeyword: return ["SymbolKeyword", node as ts.SymbolKeyword]
        // case ts.SyntaxKind.TypeKeyword: return ["TypeKeyword", node as ts.TypeKeyword]
        // case ts.SyntaxKind.UndefinedKeyword: return ["UndefinedKeyword", node as ts.UndefinedKeyword]
        // case ts.SyntaxKind.UniqueKeyword: return ["UniqueKeyword", node as ts.UniqueKeyword]
        // case ts.SyntaxKind.UnknownKeyword: return ["UnknownKeyword", node as ts.UnknownKeyword]
        // case ts.SyntaxKind.FromKeyword: return ["FromKeyword", node as ts.FromKeyword]
        // case ts.SyntaxKind.GlobalKeyword: return ["GlobalKeyword", node as ts.GlobalKeyword]
        // case ts.SyntaxKind.BigIntKeyword: return ["BigIntKeyword", node as ts.BigIntKeyword]
        // case ts.SyntaxKind.OfKeyword: return ["OfKeyword", node as ts.OfKeyword]
        case ts.SyntaxKind.QualifiedName: return ["QualifiedName", node as ts.QualifiedName]
        case ts.SyntaxKind.ComputedPropertyName: return ["ComputedPropertyName", node as ts.ComputedPropertyName]
        // case ts.SyntaxKind.TypeParameter: return ["TypeParameter", node as ts.TypeParameter]
        // case ts.SyntaxKind.Parameter: return ["Parameter", node as ts.Parameter]
        case ts.SyntaxKind.Decorator: return ["Decorator", node as ts.Decorator]
        case ts.SyntaxKind.PropertySignature: return ["PropertySignature", node as ts.PropertySignature]
        case ts.SyntaxKind.PropertyDeclaration: return ["PropertyDeclaration", node as ts.PropertyDeclaration]
        case ts.SyntaxKind.MethodSignature: return ["MethodSignature", node as ts.MethodSignature]
        case ts.SyntaxKind.MethodDeclaration: return ["MethodDeclaration", node as ts.MethodDeclaration]
        // case ts.SyntaxKind.Constructor: return ["Constructor", node as ts.Constructor]
        // case ts.SyntaxKind.GetAccessor: return ["GetAccessor", node as ts.GetAccessor]
        // case ts.SyntaxKind.SetAccessor: return ["SetAccessor", node as ts.SetAccessor]
        // case ts.SyntaxKind.CallSignature: return ["CallSignature", node as ts.CallSignature]
        // case ts.SyntaxKind.ConstructSignature: return ["ConstructSignature", node as ts.ConstructSignature]
        // case ts.SyntaxKind.IndexSignature: return ["IndexSignature", node as ts.IndexSignature]
        // case ts.SyntaxKind.TypePredicate: return ["TypePredicate", node as ts.TypePredicate]
        // case ts.SyntaxKind.TypeReference: return ["TypeReference", node as ts.TypeReference]
        // case ts.SyntaxKind.FunctionType: return ["FunctionType", node as ts.FunctionType]
        // case ts.SyntaxKind.ConstructorType: return ["ConstructorType", node as ts.ConstructorType]
        // case ts.SyntaxKind.TypeQuery: return ["TypeQuery", node as ts.TypeQuery]
        // case ts.SyntaxKind.TypeLiteral: return ["TypeLiteral", node as ts.TypeLiteral]
        // case ts.SyntaxKind.ArrayType: return ["ArrayType", node as ts.ArrayType]
        // case ts.SyntaxKind.TupleType: return ["TupleType", node as ts.TupleType]
        // case ts.SyntaxKind.OptionalType: return ["OptionalType", node as ts.OptionalType]
        // case ts.SyntaxKind.RestType: return ["RestType", node as ts.RestType]
        // case ts.SyntaxKind.UnionType: return ["UnionType", node as ts.UnionType]
        // case ts.SyntaxKind.IntersectionType: return ["IntersectionType", node as ts.IntersectionType]
        // case ts.SyntaxKind.ConditionalType: return ["ConditionalType", node as ts.ConditionalType]
        // case ts.SyntaxKind.InferType: return ["InferType", node as ts.InferType]
        // case ts.SyntaxKind.ParenthesizedType: return ["ParenthesizedType", node as ts.ParenthesizedType]
        // case ts.SyntaxKind.ThisType: return ["ThisType", node as ts.ThisType]
        // case ts.SyntaxKind.TypeOperator: return ["TypeOperator", node as ts.TypeOperator]
        // case ts.SyntaxKind.IndexedAccessType: return ["IndexedAccessType", node as ts.IndexedAccessType]
        // case ts.SyntaxKind.MappedType: return ["MappedType", node as ts.MappedType]
        // case ts.SyntaxKind.LiteralType: return ["LiteralType", node as ts.LiteralType]
        // case ts.SyntaxKind.ImportType: return ["ImportType", node as ts.ImportType]
        case ts.SyntaxKind.ObjectBindingPattern: return ["ObjectBindingPattern", node as ts.ObjectBindingPattern]
        case ts.SyntaxKind.ArrayBindingPattern: return ["ArrayBindingPattern", node as ts.ArrayBindingPattern]
        case ts.SyntaxKind.BindingElement: return ["BindingElement", node as ts.BindingElement]
        case ts.SyntaxKind.ArrayLiteralExpression: return ["ArrayLiteralExpression", node as ts.ArrayLiteralExpression]
        case ts.SyntaxKind.ObjectLiteralExpression: return ["ObjectLiteralExpression", node as ts.ObjectLiteralExpression]
        case ts.SyntaxKind.PropertyAccessExpression: return ["PropertyAccessExpression", node as ts.PropertyAccessExpression]
        case ts.SyntaxKind.ElementAccessExpression: return ["ElementAccessExpression", node as ts.ElementAccessExpression]
        case ts.SyntaxKind.CallExpression: return ["CallExpression", node as ts.CallExpression]
        case ts.SyntaxKind.NewExpression: return ["NewExpression", node as ts.NewExpression]
        case ts.SyntaxKind.TaggedTemplateExpression: return ["TaggedTemplateExpression", node as ts.TaggedTemplateExpression]
        // case ts.SyntaxKind.TypeAssertionExpression: return ["TypeAssertionExpression", node as ts.TypeAssertionExpression]
        case ts.SyntaxKind.ParenthesizedExpression: return ["ParenthesizedExpression", node as ts.ParenthesizedExpression]
        case ts.SyntaxKind.FunctionExpression: return ["FunctionExpression", node as ts.FunctionExpression]
        case ts.SyntaxKind.ArrowFunction: return ["ArrowFunction", node as ts.ArrowFunction]
        case ts.SyntaxKind.DeleteExpression: return ["DeleteExpression", node as ts.DeleteExpression]
        case ts.SyntaxKind.TypeOfExpression: return ["TypeOfExpression", node as ts.TypeOfExpression]
        case ts.SyntaxKind.VoidExpression: return ["VoidExpression", node as ts.VoidExpression]
        case ts.SyntaxKind.AwaitExpression: return ["AwaitExpression", node as ts.AwaitExpression]
        case ts.SyntaxKind.PrefixUnaryExpression: return ["PrefixUnaryExpression", node as ts.PrefixUnaryExpression]
        case ts.SyntaxKind.PostfixUnaryExpression: return ["PostfixUnaryExpression", node as ts.PostfixUnaryExpression]
        case ts.SyntaxKind.BinaryExpression: return ["BinaryExpression", node as ts.BinaryExpression]
        case ts.SyntaxKind.ConditionalExpression: return ["ConditionalExpression", node as ts.ConditionalExpression]
        case ts.SyntaxKind.TemplateExpression: return ["TemplateExpression", node as ts.TemplateExpression]
        case ts.SyntaxKind.YieldExpression: return ["YieldExpression", node as ts.YieldExpression]
        case ts.SyntaxKind.SpreadElement: return ["SpreadElement", node as ts.SpreadElement]
        case ts.SyntaxKind.ClassExpression: return ["ClassExpression", node as ts.ClassExpression]
        case ts.SyntaxKind.OmittedExpression: return ["OmittedExpression", node as ts.OmittedExpression]
        case ts.SyntaxKind.ExpressionWithTypeArguments: return ["ExpressionWithTypeArguments", node as ts.ExpressionWithTypeArguments]
        case ts.SyntaxKind.AsExpression: return ["AsExpression", node as ts.AsExpression]
        case ts.SyntaxKind.NonNullExpression: return ["NonNullExpression", node as ts.NonNullExpression]
        case ts.SyntaxKind.MetaProperty: return ["MetaProperty", node as ts.MetaProperty]
        // case ts.SyntaxKind.SyntheticExpression: return ["SyntheticExpression", node as ts.SyntheticExpression]
        case ts.SyntaxKind.TemplateSpan: return ["TemplateSpan", node as ts.TemplateSpan]
        case ts.SyntaxKind.SemicolonClassElement: return ["SemicolonClassElement", node as ts.SemicolonClassElement]
        case ts.SyntaxKind.Block: return ["Block", node as ts.Block]
        case ts.SyntaxKind.VariableStatement: return ["VariableStatement", node as ts.VariableStatement]
        case ts.SyntaxKind.EmptyStatement: return ["EmptyStatement", node as ts.EmptyStatement]
        case ts.SyntaxKind.ExpressionStatement: return ["ExpressionStatement", node as ts.ExpressionStatement]
        case ts.SyntaxKind.IfStatement: return ["IfStatement", node as ts.IfStatement]
        case ts.SyntaxKind.DoStatement: return ["DoStatement", node as ts.DoStatement]
        case ts.SyntaxKind.WhileStatement: return ["WhileStatement", node as ts.WhileStatement]
        case ts.SyntaxKind.ForStatement: return ["ForStatement", node as ts.ForStatement]
        case ts.SyntaxKind.ForInStatement: return ["ForInStatement", node as ts.ForInStatement]
        case ts.SyntaxKind.ForOfStatement: return ["ForOfStatement", node as ts.ForOfStatement]
        case ts.SyntaxKind.ContinueStatement: return ["ContinueStatement", node as ts.ContinueStatement]
        case ts.SyntaxKind.BreakStatement: return ["BreakStatement", node as ts.BreakStatement]
        case ts.SyntaxKind.ReturnStatement: return ["ReturnStatement", node as ts.ReturnStatement]
        case ts.SyntaxKind.WithStatement: return ["WithStatement", node as ts.WithStatement]
        case ts.SyntaxKind.SwitchStatement: return ["SwitchStatement", node as ts.SwitchStatement]
        case ts.SyntaxKind.LabeledStatement: return ["LabeledStatement", node as ts.LabeledStatement]
        case ts.SyntaxKind.ThrowStatement: return ["ThrowStatement", node as ts.ThrowStatement]
        case ts.SyntaxKind.TryStatement: return ["TryStatement", node as ts.TryStatement]
        case ts.SyntaxKind.DebuggerStatement: return ["DebuggerStatement", node as ts.DebuggerStatement]
        case ts.SyntaxKind.VariableDeclaration: return ["VariableDeclaration", node as ts.VariableDeclaration]
        case ts.SyntaxKind.VariableDeclarationList: return ["VariableDeclarationList", node as ts.VariableDeclarationList]
        case ts.SyntaxKind.FunctionDeclaration: return ["FunctionDeclaration", node as ts.FunctionDeclaration]
        case ts.SyntaxKind.ClassDeclaration: return ["ClassDeclaration", node as ts.ClassDeclaration]
        case ts.SyntaxKind.InterfaceDeclaration: return ["InterfaceDeclaration", node as ts.InterfaceDeclaration]
        case ts.SyntaxKind.TypeAliasDeclaration: return ["TypeAliasDeclaration", node as ts.TypeAliasDeclaration]
        case ts.SyntaxKind.EnumDeclaration: return ["EnumDeclaration", node as ts.EnumDeclaration]
        case ts.SyntaxKind.ModuleDeclaration: return ["ModuleDeclaration", node as ts.ModuleDeclaration]
        case ts.SyntaxKind.ModuleBlock: return ["ModuleBlock", node as ts.ModuleBlock]
        case ts.SyntaxKind.CaseBlock: return ["CaseBlock", node as ts.CaseBlock]
        case ts.SyntaxKind.NamespaceExportDeclaration: return ["NamespaceExportDeclaration", node as ts.NamespaceExportDeclaration]
        case ts.SyntaxKind.ImportEqualsDeclaration: return ["ImportEqualsDeclaration", node as ts.ImportEqualsDeclaration]
        case ts.SyntaxKind.ImportDeclaration: return ["ImportDeclaration", node as ts.ImportDeclaration]
        case ts.SyntaxKind.ImportClause: return ["ImportClause", node as ts.ImportClause]
        case ts.SyntaxKind.NamespaceImport: return ["NamespaceImport", node as ts.NamespaceImport]
        case ts.SyntaxKind.NamedImports: return ["NamedImports", node as ts.NamedImports]
        case ts.SyntaxKind.ImportSpecifier: return ["ImportSpecifier", node as ts.ImportSpecifier]
        case ts.SyntaxKind.ExportAssignment: return ["ExportAssignment", node as ts.ExportAssignment]
        case ts.SyntaxKind.ExportDeclaration: return ["ExportDeclaration", node as ts.ExportDeclaration]
        case ts.SyntaxKind.NamedExports: return ["NamedExports", node as ts.NamedExports]
        case ts.SyntaxKind.ExportSpecifier: return ["ExportSpecifier", node as ts.ExportSpecifier]
        case ts.SyntaxKind.MissingDeclaration: return ["MissingDeclaration", node as ts.MissingDeclaration]
        case ts.SyntaxKind.ExternalModuleReference: return ["ExternalModuleReference", node as ts.ExternalModuleReference]
        case ts.SyntaxKind.JsxElement: return ["JsxElement", node as ts.JsxElement]
        case ts.SyntaxKind.JsxSelfClosingElement: return ["JsxSelfClosingElement", node as ts.JsxSelfClosingElement]
        case ts.SyntaxKind.JsxOpeningElement: return ["JsxOpeningElement", node as ts.JsxOpeningElement]
        case ts.SyntaxKind.JsxClosingElement: return ["JsxClosingElement", node as ts.JsxClosingElement]
        case ts.SyntaxKind.JsxFragment: return ["JsxFragment", node as ts.JsxFragment]
        case ts.SyntaxKind.JsxOpeningFragment: return ["JsxOpeningFragment", node as ts.JsxOpeningFragment]
        case ts.SyntaxKind.JsxClosingFragment: return ["JsxClosingFragment", node as ts.JsxClosingFragment]
        case ts.SyntaxKind.JsxAttribute: return ["JsxAttribute", node as ts.JsxAttribute]
        case ts.SyntaxKind.JsxAttributes: return ["JsxAttributes", node as ts.JsxAttributes]
        case ts.SyntaxKind.JsxSpreadAttribute: return ["JsxSpreadAttribute", node as ts.JsxSpreadAttribute]
        case ts.SyntaxKind.JsxExpression: return ["JsxExpression", node as ts.JsxExpression]
        case ts.SyntaxKind.CaseClause: return ["CaseClause", node as ts.CaseClause]
        case ts.SyntaxKind.DefaultClause: return ["DefaultClause", node as ts.DefaultClause]
        case ts.SyntaxKind.HeritageClause: return ["HeritageClause", node as ts.HeritageClause]
        case ts.SyntaxKind.CatchClause: return ["CatchClause", node as ts.CatchClause]
        case ts.SyntaxKind.PropertyAssignment: return ["PropertyAssignment", node as ts.PropertyAssignment]
        case ts.SyntaxKind.ShorthandPropertyAssignment: return ["ShorthandPropertyAssignment", node as ts.ShorthandPropertyAssignment]
        case ts.SyntaxKind.SpreadAssignment: return ["SpreadAssignment", node as ts.SpreadAssignment]
        case ts.SyntaxKind.EnumMember: return ["EnumMember", node as ts.EnumMember]
        // case ts.SyntaxKind.UnparsedPrologue: return ["UnparsedPrologue", node as ts.UnparsedPrologue]
        // case ts.SyntaxKind.UnparsedPrepend: return ["UnparsedPrepend", node as ts.UnparsedPrepend]
        // case ts.SyntaxKind.UnparsedText: return ["UnparsedText", node as ts.UnparsedText]
        // case ts.SyntaxKind.UnparsedInternalText: return ["UnparsedInternalText", node as ts.UnparsedInternalText]
        // case ts.SyntaxKind.UnparsedSyntheticReference: return ["UnparsedSyntheticReference", node as ts.UnparsedSyntheticReference]
        case ts.SyntaxKind.SourceFile: return ["SourceFile", node as ts.SourceFile]
        case ts.SyntaxKind.Bundle: return ["Bundle", node as ts.Bundle]
        case ts.SyntaxKind.UnparsedSource: return ["UnparsedSource", node as ts.UnparsedSource]
        case ts.SyntaxKind.InputFiles: return ["InputFiles", node as ts.InputFiles]
        case ts.SyntaxKind.JSDocTypeExpression: return ["JSDocTypeExpression", node as ts.JSDocTypeExpression]
        case ts.SyntaxKind.JSDocAllType: return ["JSDocAllType", node as ts.JSDocAllType]
        case ts.SyntaxKind.JSDocUnknownType: return ["JSDocUnknownType", node as ts.JSDocUnknownType]
        case ts.SyntaxKind.JSDocNullableType: return ["JSDocNullableType", node as ts.JSDocNullableType]
        case ts.SyntaxKind.JSDocNonNullableType: return ["JSDocNonNullableType", node as ts.JSDocNonNullableType]
        case ts.SyntaxKind.JSDocOptionalType: return ["JSDocOptionalType", node as ts.JSDocOptionalType]
        case ts.SyntaxKind.JSDocFunctionType: return ["JSDocFunctionType", node as ts.JSDocFunctionType]
        case ts.SyntaxKind.JSDocVariadicType: return ["JSDocVariadicType", node as ts.JSDocVariadicType]
        // case ts.SyntaxKind.JSDocNamepathType: return ["JSDocNamepathType", node as ts.JSDocNamepathType]
        // case ts.SyntaxKind.JSDocComment: return ["JSDocComment", node as ts.JSDocComment]
        case ts.SyntaxKind.JSDocTypeLiteral: return ["JSDocTypeLiteral", node as ts.JSDocTypeLiteral]
        case ts.SyntaxKind.JSDocSignature: return ["JSDocSignature", node as ts.JSDocSignature]
        case ts.SyntaxKind.JSDocTag: return ["JSDocTag", node as ts.JSDocTag]
        case ts.SyntaxKind.JSDocAugmentsTag: return ["JSDocAugmentsTag", node as ts.JSDocAugmentsTag]
        // case ts.SyntaxKind.JSDocAuthorTag: return ["JSDocAuthorTag", node as ts.JSDocAuthorTag]
        case ts.SyntaxKind.JSDocClassTag: return ["JSDocClassTag", node as ts.JSDocClassTag]
        case ts.SyntaxKind.JSDocCallbackTag: return ["JSDocCallbackTag", node as ts.JSDocCallbackTag]
        // case ts.SyntaxKind.JSDocEnumTag: return ["JSDocEnumTag", node as ts.JSDocEnumTag]
        case ts.SyntaxKind.JSDocParameterTag: return ["JSDocParameterTag", node as ts.JSDocParameterTag]
        case ts.SyntaxKind.JSDocReturnTag: return ["JSDocReturnTag", node as ts.JSDocReturnTag]
        // case ts.SyntaxKind.JSDocThisTag: return ["JSDocThisTag", node as ts.JSDocThisTag]
        case ts.SyntaxKind.JSDocTypeTag: return ["JSDocTypeTag", node as ts.JSDocTypeTag]
        case ts.SyntaxKind.JSDocTemplateTag: return ["JSDocTemplateTag", node as ts.JSDocTemplateTag]
        case ts.SyntaxKind.JSDocTypedefTag: return ["JSDocTypedefTag", node as ts.JSDocTypedefTag]
        case ts.SyntaxKind.JSDocPropertyTag: return ["JSDocPropertyTag", node as ts.JSDocPropertyTag]
        case ts.SyntaxKind.SyntaxList: return ["SyntaxList", node as ts.SyntaxList]
        case ts.SyntaxKind.NotEmittedStatement: return ["NotEmittedStatement", node as ts.NotEmittedStatement]
        case ts.SyntaxKind.PartiallyEmittedExpression: return ["PartiallyEmittedExpression", node as ts.PartiallyEmittedExpression]
        case ts.SyntaxKind.CommaListExpression: return ["CommaListExpression", node as ts.CommaListExpression]
        // case ts.SyntaxKind.MergeDeclarationMarker: return ["MergeDeclarationMarker", node as ts.MergeDeclarationMarker]
        // case ts.SyntaxKind.EndOfDeclarationMarker: return ["EndOfDeclarationMarker", node as ts.EndOfDeclarationMarker]
        // case ts.SyntaxKind.Count: return ["Count", node as ts.Count]
        default: return null
    }
}


export type GeneratedUncastableNode =
    | ["Unknown"]
    // | ["EndOfFileToken"]
    | ["SingleLineCommentTrivia"]
    | ["MultiLineCommentTrivia"]
    | ["NewLineTrivia"]
    | ["WhitespaceTrivia"]
    | ["ShebangTrivia"]
    | ["ConflictMarkerTrivia"]
    // | ["NumericLiteral"]
    // | ["BigIntLiteral"]
    // | ["StringLiteral"]
    // | ["JsxText"]
    | ["JsxTextAllWhiteSpaces"]
    // | ["RegularExpressionLiteral"]
    // | ["NoSubstitutionTemplateLiteral"]
    // | ["TemplateHead"]
    // | ["TemplateMiddle"]
    // | ["TemplateTail"]
    | ["OpenBraceToken"]
    | ["CloseBraceToken"]
    | ["OpenParenToken"]
    | ["CloseParenToken"]
    | ["OpenBracketToken"]
    | ["CloseBracketToken"]
    | ["DotToken"]
    // | ["DotDotDotToken"]
    | ["SemicolonToken"]
    | ["CommaToken"]
    | ["LessThanToken"]
    | ["LessThanSlashToken"]
    | ["GreaterThanToken"]
    | ["LessThanEqualsToken"]
    | ["GreaterThanEqualsToken"]
    | ["EqualsEqualsToken"]
    | ["ExclamationEqualsToken"]
    | ["EqualsEqualsEqualsToken"]
    | ["ExclamationEqualsEqualsToken"]
    // | ["EqualsGreaterThanToken"]
    // | ["PlusToken"]
    // | ["MinusToken"]
    // | ["AsteriskToken"]
    | ["AsteriskAsteriskToken"]
    | ["SlashToken"]
    | ["PercentToken"]
    | ["PlusPlusToken"]
    | ["MinusMinusToken"]
    | ["LessThanLessThanToken"]
    | ["GreaterThanGreaterThanToken"]
    | ["GreaterThanGreaterThanGreaterThanToken"]
    | ["AmpersandToken"]
    | ["BarToken"]
    | ["CaretToken"]
    // | ["ExclamationToken"]
    | ["TildeToken"]
    | ["AmpersandAmpersandToken"]
    | ["BarBarToken"]
    // | ["QuestionToken"]
    // | ["ColonToken"]
    | ["AtToken"]
    /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
    | ["BacktickToken"]
    // | ["EqualsToken"]
    | ["PlusEqualsToken"]
    | ["MinusEqualsToken"]
    | ["AsteriskEqualsToken"]
    | ["AsteriskAsteriskEqualsToken"]
    | ["SlashEqualsToken"]
    | ["PercentEqualsToken"]
    | ["LessThanLessThanEqualsToken"]
    | ["GreaterThanGreaterThanEqualsToken"]
    | ["GreaterThanGreaterThanGreaterThanEqualsToken"]
    | ["AmpersandEqualsToken"]
    | ["BarEqualsToken"]
    | ["CaretEqualsToken"]
    // | ["Identifier"]
    | ["BreakKeyword"]
    | ["CaseKeyword"]
    | ["CatchKeyword"]
    | ["ClassKeyword"]
    | ["ConstKeyword"]
    | ["ContinueKeyword"]
    | ["DebuggerKeyword"]
    | ["DefaultKeyword"]
    | ["DeleteKeyword"]
    | ["DoKeyword"]
    | ["ElseKeyword"]
    | ["EnumKeyword"]
    | ["ExportKeyword"]
    | ["ExtendsKeyword"]
    | ["FalseKeyword"]
    | ["FinallyKeyword"]
    | ["ForKeyword"]
    | ["FunctionKeyword"]
    | ["IfKeyword"]
    | ["ImportKeyword"]
    | ["InKeyword"]
    | ["InstanceOfKeyword"]
    | ["NewKeyword"]
    //| ["NullKeyword"]
    | ["ReturnKeyword"]
    | ["SuperKeyword"]
    | ["SwitchKeyword"]
    | ["ThisKeyword"]
    | ["ThrowKeyword"]
    | ["TrueKeyword"]
    | ["TryKeyword"]
    | ["TypeOfKeyword"]
    | ["VarKeyword"]
    | ["VoidKeyword"]
    | ["WhileKeyword"]
    | ["WithKeyword"]
    | ["ImplementsKeyword"]
    | ["InterfaceKeyword"]
    | ["LetKeyword"]
    | ["PackageKeyword"]
    | ["PrivateKeyword"]
    | ["ProtectedKeyword"]
    | ["PublicKeyword"]
    | ["StaticKeyword"]
    | ["YieldKeyword"]
    | ["AbstractKeyword"]
    | ["AsKeyword"]
    | ["AnyKeyword"]
    | ["AsyncKeyword"]
    | ["AwaitKeyword"]
    | ["BooleanKeyword"]
    | ["ConstructorKeyword"]
    | ["DeclareKeyword"]
    | ["GetKeyword"]
    | ["InferKeyword"]
    | ["IsKeyword"]
    | ["KeyOfKeyword"]
    | ["ModuleKeyword"]
    | ["NamespaceKeyword"]
    | ["NeverKeyword"]
    | ["ReadonlyKeyword"]
    | ["RequireKeyword"]
    | ["NumberKeyword"]
    | ["ObjectKeyword"]
    | ["SetKeyword"]
    | ["StringKeyword"]
    | ["SymbolKeyword"]
    | ["TypeKeyword"]
    | ["UndefinedKeyword"]
    | ["UniqueKeyword"]
    | ["UnknownKeyword"]
    | ["FromKeyword"]
    | ["GlobalKeyword"]
    | ["BigIntKeyword"]
    | ["OfKeyword"]
    // | ["QualifiedName"]
    // | ["ComputedPropertyName"]
    | ["TypeParameter"]
    | ["Parameter"]
    // | ["Decorator"]
    // | ["PropertySignature"]
    // | ["PropertyDeclaration"]
    // | ["MethodSignature"]
    // | ["MethodDeclaration"]
    | ["Constructor"]
    | ["GetAccessor"]
    | ["SetAccessor"]
    | ["CallSignature"]
    | ["ConstructSignature"]
    | ["IndexSignature"]
    | ["TypePredicate"]
    | ["TypeReference"]
    | ["FunctionType"]
    | ["ConstructorType"]
    | ["TypeQuery"]
    | ["TypeLiteral"]
    | ["ArrayType"]
    | ["TupleType"]
    | ["OptionalType"]
    | ["RestType"]
    | ["UnionType"]
    | ["IntersectionType"]
    | ["ConditionalType"]
    | ["InferType"]
    | ["ParenthesizedType"]
    | ["ThisType"]
    | ["TypeOperator"]
    | ["IndexedAccessType"]
    | ["MappedType"]
    | ["LiteralType"]
    | ["ImportType"]
    // | ["ObjectBindingPattern"]
    // | ["ArrayBindingPattern"]
    // | ["BindingElement"]
    // | ["ArrayLiteralExpression"]
    // | ["ObjectLiteralExpression"]
    // | ["PropertyAccessExpression"]
    // | ["ElementAccessExpression"]
    // | ["CallExpression"]
    // | ["NewExpression"]
    // | ["TaggedTemplateExpression"]
    | ["TypeAssertionExpression"]
    // | ["ParenthesizedExpression"]
    // | ["FunctionExpression"]
    // | ["ArrowFunction"]
    // | ["DeleteExpression"]
    // | ["TypeOfExpression"]
    // | ["VoidExpression"]
    // | ["AwaitExpression"]
    // | ["PrefixUnaryExpression"]
    // | ["PostfixUnaryExpression"]
    // | ["BinaryExpression"]
    // | ["ConditionalExpression"]
    // | ["TemplateExpression"]
    // | ["YieldExpression"]
    // | ["SpreadElement"]
    // | ["ClassExpression"]
    // | ["OmittedExpression"]
    // | ["ExpressionWithTypeArguments"]
    // | ["AsExpression"]
    // | ["NonNullExpression"]
    // | ["MetaProperty"]
    // | ["SyntheticExpression"]
    // | ["TemplateSpan"]
    // | ["SemicolonClassElement"]
    // | ["Block"]
    // | ["VariableStatement"]
    // | ["EmptyStatement"]
    // | ["ExpressionStatement"]
    // | ["IfStatement"]
    // | ["DoStatement"]
    // | ["WhileStatement"]
    // | ["ForStatement"]
    // | ["ForInStatement"]
    // | ["ForOfStatement"]
    // | ["ContinueStatement"]
    // | ["BreakStatement"]
    // | ["ReturnStatement"]
    // | ["WithStatement"]
    // | ["SwitchStatement"]
    // | ["LabeledStatement"]
    // | ["ThrowStatement"]
    // | ["TryStatement"]
    // | ["DebuggerStatement"]
    // | ["VariableDeclaration"]
    // | ["VariableDeclarationList"]
    // | ["FunctionDeclaration"]
    // | ["ClassDeclaration"]
    // | ["InterfaceDeclaration"]
    // | ["TypeAliasDeclaration"]
    // | ["EnumDeclaration"]
    // | ["ModuleDeclaration"]
    // | ["ModuleBlock"]
    // | ["CaseBlock"]
    // | ["NamespaceExportDeclaration"]
    // | ["ImportEqualsDeclaration"]
    // | ["ImportDeclaration"]
    // | ["ImportClause"]
    // | ["NamespaceImport"]
    // | ["NamedImports"]
    // | ["ImportSpecifier"]
    // | ["ExportAssignment"]
    // | ["ExportDeclaration"]
    // | ["NamedExports"]
    // | ["ExportSpecifier"]
    // | ["MissingDeclaration"]
    // | ["ExternalModuleReference"]
    // | ["JsxElement"]
    // | ["JsxSelfClosingElement"]
    // | ["JsxOpeningElement"]
    // | ["JsxClosingElement"]
    // | ["JsxFragment"]
    // | ["JsxOpeningFragment"]
    // | ["JsxClosingFragment"]
    // | ["JsxAttribute"]
    // | ["JsxAttributes"]
    // | ["JsxSpreadAttribute"]
    // | ["JsxExpression"]
    // | ["CaseClause"]
    // | ["DefaultClause"]
    // | ["HeritageClause"]
    // | ["CatchClause"]
    // | ["PropertyAssignment"]
    // | ["ShorthandPropertyAssignment"]
    // | ["SpreadAssignment"]
    // | ["EnumMember"]
    // | ["UnparsedPrologue"]
    // | ["UnparsedPrepend"]
    | ["UnparsedText"]
    | ["UnparsedInternalText"]
    // | ["UnparsedSyntheticReference"]
    // | ["SourceFile"]
    // | ["Bundle"]
    // | ["UnparsedSource"]
    // | ["InputFiles"]
    // | ["JSDocTypeExpression"]
    // | ["JSDocAllType"]
    // | ["JSDocUnknownType"]
    // | ["JSDocNullableType"]
    // | ["JSDocNonNullableType"]
    // | ["JSDocOptionalType"]
    // | ["JSDocFunctionType"]
    // | ["JSDocVariadicType"]
    // | ["JSDocNamepathType"]
    | ["JSDocComment"]
    // | ["JSDocTypeLiteral"]
    // | ["JSDocSignature"]
    // | ["JSDocTag"]
    // | ["JSDocAugmentsTag"]
    // | ["JSDocAuthorTag"]
    // | ["JSDocClassTag"]
    // | ["JSDocCallbackTag"]
    // | ["JSDocEnumTag"]
    // | ["JSDocParameterTag"]
    // | ["JSDocReturnTag"]
    // | ["JSDocThisTag"]
    // | ["JSDocTypeTag"]
    // | ["JSDocTemplateTag"]
    // | ["JSDocTypedefTag"]
    // | ["JSDocPropertyTag"]
    // | ["SyntaxList"]
    // | ["NotEmittedStatement"]
    // | ["PartiallyEmittedExpression"]
    // | ["CommaListExpression"]
    | ["MergeDeclarationMarker"]
    | ["EndOfDeclarationMarker"]
    | ["Count"]


export function castUnsupportedNode(node: ts.Node): GeneratedUncastableNode | null {
    switch (node.kind) {
        case ts.SyntaxKind.Unknown: return ["Unknown"]
        // case ts.SyntaxKind.EndOfFileToken: return ["EndOfFileToken"]
        case ts.SyntaxKind.SingleLineCommentTrivia: return ["SingleLineCommentTrivia"]
        case ts.SyntaxKind.MultiLineCommentTrivia: return ["MultiLineCommentTrivia"]
        case ts.SyntaxKind.NewLineTrivia: return ["NewLineTrivia"]
        case ts.SyntaxKind.WhitespaceTrivia: return ["WhitespaceTrivia"]
        case ts.SyntaxKind.ShebangTrivia: return ["ShebangTrivia"]
        case ts.SyntaxKind.ConflictMarkerTrivia: return ["ConflictMarkerTrivia"]
        // case ts.SyntaxKind.NumericLiteral: return ["NumericLiteral"]
        // case ts.SyntaxKind.BigIntLiteral: return ["BigIntLiteral"]
        // case ts.SyntaxKind.StringLiteral: return ["StringLiteral"]
        // case ts.SyntaxKind.JsxText: return ["JsxText"]
        case ts.SyntaxKind.JsxTextAllWhiteSpaces: return ["JsxTextAllWhiteSpaces"]
        // case ts.SyntaxKind.RegularExpressionLiteral: return ["RegularExpressionLiteral"]
        // case ts.SyntaxKind.NoSubstitutionTemplateLiteral: return ["NoSubstitutionTemplateLiteral"]
        // case ts.SyntaxKind.TemplateHead: return ["TemplateHead"]
        // case ts.SyntaxKind.TemplateMiddle: return ["TemplateMiddle"]
        // case ts.SyntaxKind.TemplateTail: return ["TemplateTail"]
        case ts.SyntaxKind.OpenBraceToken: return ["OpenBraceToken"]
        case ts.SyntaxKind.CloseBraceToken: return ["CloseBraceToken"]
        case ts.SyntaxKind.OpenParenToken: return ["OpenParenToken"]
        case ts.SyntaxKind.CloseParenToken: return ["CloseParenToken"]
        case ts.SyntaxKind.OpenBracketToken: return ["OpenBracketToken"]
        case ts.SyntaxKind.CloseBracketToken: return ["CloseBracketToken"]
        case ts.SyntaxKind.DotToken: return ["DotToken"]
        // case ts.SyntaxKind.DotDotDotToken: return ["DotDotDotToken"]
        case ts.SyntaxKind.SemicolonToken: return ["SemicolonToken"]
        case ts.SyntaxKind.CommaToken: return ["CommaToken"]
        case ts.SyntaxKind.LessThanToken: return ["LessThanToken"]
        case ts.SyntaxKind.LessThanSlashToken: return ["LessThanSlashToken"]
        case ts.SyntaxKind.GreaterThanToken: return ["GreaterThanToken"]
        case ts.SyntaxKind.LessThanEqualsToken: return ["LessThanEqualsToken"]
        case ts.SyntaxKind.GreaterThanEqualsToken: return ["GreaterThanEqualsToken"]
        case ts.SyntaxKind.EqualsEqualsToken: return ["EqualsEqualsToken"]
        case ts.SyntaxKind.ExclamationEqualsToken: return ["ExclamationEqualsToken"]
        case ts.SyntaxKind.EqualsEqualsEqualsToken: return ["EqualsEqualsEqualsToken"]
        case ts.SyntaxKind.ExclamationEqualsEqualsToken: return ["ExclamationEqualsEqualsToken"]
        // case ts.SyntaxKind.EqualsGreaterThanToken: return ["EqualsGreaterThanToken"]
        // case ts.SyntaxKind.PlusToken: return ["PlusToken"]
        // case ts.SyntaxKind.MinusToken: return ["MinusToken"]
        // case ts.SyntaxKind.AsteriskToken: return ["AsteriskToken"]
        case ts.SyntaxKind.AsteriskAsteriskToken: return ["AsteriskAsteriskToken"]
        case ts.SyntaxKind.SlashToken: return ["SlashToken"]
        case ts.SyntaxKind.PercentToken: return ["PercentToken"]
        case ts.SyntaxKind.PlusPlusToken: return ["PlusPlusToken"]
        case ts.SyntaxKind.MinusMinusToken: return ["MinusMinusToken"]
        case ts.SyntaxKind.LessThanLessThanToken: return ["LessThanLessThanToken"]
        case ts.SyntaxKind.GreaterThanGreaterThanToken: return ["GreaterThanGreaterThanToken"]
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken: return ["GreaterThanGreaterThanGreaterThanToken"]
        case ts.SyntaxKind.AmpersandToken: return ["AmpersandToken"]
        case ts.SyntaxKind.BarToken: return ["BarToken"]
        case ts.SyntaxKind.CaretToken: return ["CaretToken"]
        // case ts.SyntaxKind.ExclamationToken: return ["ExclamationToken"]
        case ts.SyntaxKind.TildeToken: return ["TildeToken"]
        case ts.SyntaxKind.AmpersandAmpersandToken: return ["AmpersandAmpersandToken"]
        case ts.SyntaxKind.BarBarToken: return ["BarBarToken"]
        // case ts.SyntaxKind.QuestionToken: return ["QuestionToken"]
        // case ts.SyntaxKind.ColonToken: return ["ColonToken"]
        case ts.SyntaxKind.AtToken: return ["AtToken"]
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        // case ts.SyntaxKind.BacktickToken: return ["BacktickToken"]
        // case ts.SyntaxKind.EqualsToken: return ["EqualsToken"]
        case ts.SyntaxKind.PlusEqualsToken: return ["PlusEqualsToken"]
        case ts.SyntaxKind.MinusEqualsToken: return ["MinusEqualsToken"]
        case ts.SyntaxKind.AsteriskEqualsToken: return ["AsteriskEqualsToken"]
        case ts.SyntaxKind.AsteriskAsteriskEqualsToken: return ["AsteriskAsteriskEqualsToken"]
        case ts.SyntaxKind.SlashEqualsToken: return ["SlashEqualsToken"]
        case ts.SyntaxKind.PercentEqualsToken: return ["PercentEqualsToken"]
        case ts.SyntaxKind.LessThanLessThanEqualsToken: return ["LessThanLessThanEqualsToken"]
        case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken: return ["GreaterThanGreaterThanEqualsToken"]
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken: return ["GreaterThanGreaterThanGreaterThanEqualsToken"]
        case ts.SyntaxKind.AmpersandEqualsToken: return ["AmpersandEqualsToken"]
        case ts.SyntaxKind.BarEqualsToken: return ["BarEqualsToken"]
        case ts.SyntaxKind.CaretEqualsToken: return ["CaretEqualsToken"]
        // case ts.SyntaxKind.Identifier: return ["Identifier"]
        case ts.SyntaxKind.BreakKeyword: return ["BreakKeyword"]
        case ts.SyntaxKind.CaseKeyword: return ["CaseKeyword"]
        case ts.SyntaxKind.CatchKeyword: return ["CatchKeyword"]
        case ts.SyntaxKind.ClassKeyword: return ["ClassKeyword"]
        case ts.SyntaxKind.ConstKeyword: return ["ConstKeyword"]
        case ts.SyntaxKind.ContinueKeyword: return ["ContinueKeyword"]
        case ts.SyntaxKind.DebuggerKeyword: return ["DebuggerKeyword"]
        case ts.SyntaxKind.DefaultKeyword: return ["DefaultKeyword"]
        case ts.SyntaxKind.DeleteKeyword: return ["DeleteKeyword"]
        case ts.SyntaxKind.DoKeyword: return ["DoKeyword"]
        case ts.SyntaxKind.ElseKeyword: return ["ElseKeyword"]
        case ts.SyntaxKind.EnumKeyword: return ["EnumKeyword"]
        case ts.SyntaxKind.ExportKeyword: return ["ExportKeyword"]
        case ts.SyntaxKind.ExtendsKeyword: return ["ExtendsKeyword"]
        case ts.SyntaxKind.FalseKeyword: return ["FalseKeyword"]
        case ts.SyntaxKind.FinallyKeyword: return ["FinallyKeyword"]
        case ts.SyntaxKind.ForKeyword: return ["ForKeyword"]
        case ts.SyntaxKind.FunctionKeyword: return ["FunctionKeyword"]
        case ts.SyntaxKind.IfKeyword: return ["IfKeyword"]
        case ts.SyntaxKind.ImportKeyword: return ["ImportKeyword"]
        case ts.SyntaxKind.InKeyword: return ["InKeyword"]
        case ts.SyntaxKind.InstanceOfKeyword: return ["InstanceOfKeyword"]
        case ts.SyntaxKind.NewKeyword: return ["NewKeyword"]
        //case ts.SyntaxKind.NullKeyword: return ["NullKeyword"]
        case ts.SyntaxKind.ReturnKeyword: return ["ReturnKeyword"]
        case ts.SyntaxKind.SuperKeyword: return ["SuperKeyword"]
        case ts.SyntaxKind.SwitchKeyword: return ["SwitchKeyword"]
        case ts.SyntaxKind.ThisKeyword: return ["ThisKeyword"]
        case ts.SyntaxKind.ThrowKeyword: return ["ThrowKeyword"]
        case ts.SyntaxKind.TrueKeyword: return ["TrueKeyword"]
        case ts.SyntaxKind.TryKeyword: return ["TryKeyword"]
        case ts.SyntaxKind.TypeOfKeyword: return ["TypeOfKeyword"]
        case ts.SyntaxKind.VarKeyword: return ["VarKeyword"]
        case ts.SyntaxKind.VoidKeyword: return ["VoidKeyword"]
        case ts.SyntaxKind.WhileKeyword: return ["WhileKeyword"]
        case ts.SyntaxKind.WithKeyword: return ["WithKeyword"]
        case ts.SyntaxKind.ImplementsKeyword: return ["ImplementsKeyword"]
        case ts.SyntaxKind.InterfaceKeyword: return ["InterfaceKeyword"]
        case ts.SyntaxKind.LetKeyword: return ["LetKeyword"]
        case ts.SyntaxKind.PackageKeyword: return ["PackageKeyword"]
        case ts.SyntaxKind.PrivateKeyword: return ["PrivateKeyword"]
        case ts.SyntaxKind.ProtectedKeyword: return ["ProtectedKeyword"]
        case ts.SyntaxKind.PublicKeyword: return ["PublicKeyword"]
        case ts.SyntaxKind.StaticKeyword: return ["StaticKeyword"]
        case ts.SyntaxKind.YieldKeyword: return ["YieldKeyword"]
        case ts.SyntaxKind.AbstractKeyword: return ["AbstractKeyword"]
        case ts.SyntaxKind.AsKeyword: return ["AsKeyword"]
        case ts.SyntaxKind.AnyKeyword: return ["AnyKeyword"]
        case ts.SyntaxKind.AsyncKeyword: return ["AsyncKeyword"]
        case ts.SyntaxKind.AwaitKeyword: return ["AwaitKeyword"]
        case ts.SyntaxKind.BooleanKeyword: return ["BooleanKeyword"]
        case ts.SyntaxKind.ConstructorKeyword: return ["ConstructorKeyword"]
        case ts.SyntaxKind.DeclareKeyword: return ["DeclareKeyword"]
        case ts.SyntaxKind.GetKeyword: return ["GetKeyword"]
        case ts.SyntaxKind.InferKeyword: return ["InferKeyword"]
        case ts.SyntaxKind.IsKeyword: return ["IsKeyword"]
        case ts.SyntaxKind.KeyOfKeyword: return ["KeyOfKeyword"]
        case ts.SyntaxKind.ModuleKeyword: return ["ModuleKeyword"]
        case ts.SyntaxKind.NamespaceKeyword: return ["NamespaceKeyword"]
        case ts.SyntaxKind.NeverKeyword: return ["NeverKeyword"]
        case ts.SyntaxKind.ReadonlyKeyword: return ["ReadonlyKeyword"]
        case ts.SyntaxKind.RequireKeyword: return ["RequireKeyword"]
        case ts.SyntaxKind.NumberKeyword: return ["NumberKeyword"]
        case ts.SyntaxKind.ObjectKeyword: return ["ObjectKeyword"]
        case ts.SyntaxKind.SetKeyword: return ["SetKeyword"]
        case ts.SyntaxKind.StringKeyword: return ["StringKeyword"]
        case ts.SyntaxKind.SymbolKeyword: return ["SymbolKeyword"]
        case ts.SyntaxKind.TypeKeyword: return ["TypeKeyword"]
        case ts.SyntaxKind.UndefinedKeyword: return ["UndefinedKeyword"]
        case ts.SyntaxKind.UniqueKeyword: return ["UniqueKeyword"]
        case ts.SyntaxKind.UnknownKeyword: return ["UnknownKeyword"]
        case ts.SyntaxKind.FromKeyword: return ["FromKeyword"]
        case ts.SyntaxKind.GlobalKeyword: return ["GlobalKeyword"]
        // case ts.SyntaxKind.BigIntKeyword: return ["BigIntKeyword"]
        case ts.SyntaxKind.OfKeyword: return ["OfKeyword"]
        // case ts.SyntaxKind.QualifiedName: return ["QualifiedName"]
        // case ts.SyntaxKind.ComputedPropertyName: return ["ComputedPropertyName"]
        case ts.SyntaxKind.TypeParameter: return ["TypeParameter"]
        case ts.SyntaxKind.Parameter: return ["Parameter"]
        // case ts.SyntaxKind.Decorator: return ["Decorator"]
        // case ts.SyntaxKind.PropertySignature: return ["PropertySignature"]
        // case ts.SyntaxKind.PropertyDeclaration: return ["PropertyDeclaration"]
        // case ts.SyntaxKind.MethodSignature: return ["MethodSignature"]
        // case ts.SyntaxKind.MethodDeclaration: return ["MethodDeclaration"]
        case ts.SyntaxKind.Constructor: return ["Constructor"]
        case ts.SyntaxKind.GetAccessor: return ["GetAccessor"]
        case ts.SyntaxKind.SetAccessor: return ["SetAccessor"]
        case ts.SyntaxKind.CallSignature: return ["CallSignature"]
        case ts.SyntaxKind.ConstructSignature: return ["ConstructSignature"]
        case ts.SyntaxKind.IndexSignature: return ["IndexSignature"]
        case ts.SyntaxKind.TypePredicate: return ["TypePredicate"]
        case ts.SyntaxKind.TypeReference: return ["TypeReference"]
        case ts.SyntaxKind.FunctionType: return ["FunctionType"]
        case ts.SyntaxKind.ConstructorType: return ["ConstructorType"]
        case ts.SyntaxKind.TypeQuery: return ["TypeQuery"]
        case ts.SyntaxKind.TypeLiteral: return ["TypeLiteral"]
        case ts.SyntaxKind.ArrayType: return ["ArrayType"]
        case ts.SyntaxKind.TupleType: return ["TupleType"]
        // case ts.SyntaxKind.OptionalType: return ["OptionalType"]
        // case ts.SyntaxKind.RestType: return ["RestType"]
        case ts.SyntaxKind.UnionType: return ["UnionType"]
        case ts.SyntaxKind.IntersectionType: return ["IntersectionType"]
        case ts.SyntaxKind.ConditionalType: return ["ConditionalType"]
        case ts.SyntaxKind.InferType: return ["InferType"]
        case ts.SyntaxKind.ParenthesizedType: return ["ParenthesizedType"]
        case ts.SyntaxKind.ThisType: return ["ThisType"]
        case ts.SyntaxKind.TypeOperator: return ["TypeOperator"]
        case ts.SyntaxKind.IndexedAccessType: return ["IndexedAccessType"]
        case ts.SyntaxKind.MappedType: return ["MappedType"]
        case ts.SyntaxKind.LiteralType: return ["LiteralType"]
        case ts.SyntaxKind.ImportType: return ["ImportType"]
        // case ts.SyntaxKind.ObjectBindingPattern: return ["ObjectBindingPattern"]
        // case ts.SyntaxKind.ArrayBindingPattern: return ["ArrayBindingPattern"]
        // case ts.SyntaxKind.BindingElement: return ["BindingElement"]
        // case ts.SyntaxKind.ArrayLiteralExpression: return ["ArrayLiteralExpression"]
        // case ts.SyntaxKind.ObjectLiteralExpression: return ["ObjectLiteralExpression"]
        // case ts.SyntaxKind.PropertyAccessExpression: return ["PropertyAccessExpression"]
        // case ts.SyntaxKind.ElementAccessExpression: return ["ElementAccessExpression"]
        // case ts.SyntaxKind.CallExpression: return ["CallExpression"]
        // case ts.SyntaxKind.NewExpression: return ["NewExpression"]
        // case ts.SyntaxKind.TaggedTemplateExpression: return ["TaggedTemplateExpression"]
        case ts.SyntaxKind.TypeAssertionExpression: return ["TypeAssertionExpression"]
        // case ts.SyntaxKind.ParenthesizedExpression: return ["ParenthesizedExpression"]
        // case ts.SyntaxKind.FunctionExpression: return ["FunctionExpression"]
        // case ts.SyntaxKind.ArrowFunction: return ["ArrowFunction"]
        // case ts.SyntaxKind.DeleteExpression: return ["DeleteExpression"]
        // case ts.SyntaxKind.TypeOfExpression: return ["TypeOfExpression"]
        // case ts.SyntaxKind.VoidExpression: return ["VoidExpression"]
        // case ts.SyntaxKind.AwaitExpression: return ["AwaitExpression"]
        // case ts.SyntaxKind.PrefixUnaryExpression: return ["PrefixUnaryExpression"]
        // case ts.SyntaxKind.PostfixUnaryExpression: return ["PostfixUnaryExpression"]
        // case ts.SyntaxKind.BinaryExpression: return ["BinaryExpression"]
        // case ts.SyntaxKind.ConditionalExpression: return ["ConditionalExpression"]
        // case ts.SyntaxKind.TemplateExpression: return ["TemplateExpression"]
        // case ts.SyntaxKind.YieldExpression: return ["YieldExpression"]
        // case ts.SyntaxKind.SpreadElement: return ["SpreadElement"]
        // case ts.SyntaxKind.ClassExpression: return ["ClassExpression"]
        // case ts.SyntaxKind.OmittedExpression: return ["OmittedExpression"]
        // case ts.SyntaxKind.ExpressionWithTypeArguments: return ["ExpressionWithTypeArguments"]
        // case ts.SyntaxKind.AsExpression: return ["AsExpression"]
        // case ts.SyntaxKind.NonNullExpression: return ["NonNullExpression"]
        // case ts.SyntaxKind.MetaProperty: return ["MetaProperty"]
        // case ts.SyntaxKind.SyntheticExpression: return ["SyntheticExpression"]
        // case ts.SyntaxKind.TemplateSpan: return ["TemplateSpan"]
        // case ts.SyntaxKind.SemicolonClassElement: return ["SemicolonClassElement"]
        // case ts.SyntaxKind.Block: return ["Block"]
        // case ts.SyntaxKind.VariableStatement: return ["VariableStatement"]
        // case ts.SyntaxKind.EmptyStatement: return ["EmptyStatement"]
        // case ts.SyntaxKind.ExpressionStatement: return ["ExpressionStatement"]
        // case ts.SyntaxKind.IfStatement: return ["IfStatement"]
        // case ts.SyntaxKind.DoStatement: return ["DoStatement"]
        // case ts.SyntaxKind.WhileStatement: return ["WhileStatement"]
        // case ts.SyntaxKind.ForStatement: return ["ForStatement"]
        // case ts.SyntaxKind.ForInStatement: return ["ForInStatement"]
        // case ts.SyntaxKind.ForOfStatement: return ["ForOfStatement"]
        // case ts.SyntaxKind.ContinueStatement: return ["ContinueStatement"]
        // case ts.SyntaxKind.BreakStatement: return ["BreakStatement"]
        // case ts.SyntaxKind.ReturnStatement: return ["ReturnStatement"]
        // case ts.SyntaxKind.WithStatement: return ["WithStatement"]
        // case ts.SyntaxKind.SwitchStatement: return ["SwitchStatement"]
        // case ts.SyntaxKind.LabeledStatement: return ["LabeledStatement"]
        // case ts.SyntaxKind.ThrowStatement: return ["ThrowStatement"]
        // case ts.SyntaxKind.TryStatement: return ["TryStatement"]
        // case ts.SyntaxKind.DebuggerStatement: return ["DebuggerStatement"]
        // case ts.SyntaxKind.VariableDeclaration: return ["VariableDeclaration"]
        // case ts.SyntaxKind.VariableDeclarationList: return ["VariableDeclarationList"]
        // case ts.SyntaxKind.FunctionDeclaration: return ["FunctionDeclaration"]
        // case ts.SyntaxKind.ClassDeclaration: return ["ClassDeclaration"]
        // case ts.SyntaxKind.InterfaceDeclaration: return ["InterfaceDeclaration"]
        // case ts.SyntaxKind.TypeAliasDeclaration: return ["TypeAliasDeclaration"]
        // case ts.SyntaxKind.EnumDeclaration: return ["EnumDeclaration"]
        // case ts.SyntaxKind.ModuleDeclaration: return ["ModuleDeclaration"]
        // case ts.SyntaxKind.ModuleBlock: return ["ModuleBlock"]
        // case ts.SyntaxKind.CaseBlock: return ["CaseBlock"]
        // case ts.SyntaxKind.NamespaceExportDeclaration: return ["NamespaceExportDeclaration"]
        // case ts.SyntaxKind.ImportEqualsDeclaration: return ["ImportEqualsDeclaration"]
        // case ts.SyntaxKind.ImportDeclaration: return ["ImportDeclaration"]
        // case ts.SyntaxKind.ImportClause: return ["ImportClause"]
        // case ts.SyntaxKind.NamespaceImport: return ["NamespaceImport"]
        // case ts.SyntaxKind.NamedImports: return ["NamedImports"]
        // case ts.SyntaxKind.ImportSpecifier: return ["ImportSpecifier"]
        // case ts.SyntaxKind.ExportAssignment: return ["ExportAssignment"]
        // case ts.SyntaxKind.ExportDeclaration: return ["ExportDeclaration"]
        // case ts.SyntaxKind.NamedExports: return ["NamedExports"]
        // case ts.SyntaxKind.ExportSpecifier: return ["ExportSpecifier"]
        // case ts.SyntaxKind.MissingDeclaration: return ["MissingDeclaration"]
        // case ts.SyntaxKind.ExternalModuleReference: return ["ExternalModuleReference"]
        // case ts.SyntaxKind.JsxElement: return ["JsxElement"]
        // case ts.SyntaxKind.JsxSelfClosingElement: return ["JsxSelfClosingElement"]
        // case ts.SyntaxKind.JsxOpeningElement: return ["JsxOpeningElement"]
        // case ts.SyntaxKind.JsxClosingElement: return ["JsxClosingElement"]
        // case ts.SyntaxKind.JsxFragment: return ["JsxFragment"]
        // case ts.SyntaxKind.JsxOpeningFragment: return ["JsxOpeningFragment"]
        // case ts.SyntaxKind.JsxClosingFragment: return ["JsxClosingFragment"]
        // case ts.SyntaxKind.JsxAttribute: return ["JsxAttribute"]
        // case ts.SyntaxKind.JsxAttributes: return ["JsxAttributes"]
        // case ts.SyntaxKind.JsxSpreadAttribute: return ["JsxSpreadAttribute"]
        // case ts.SyntaxKind.JsxExpression: return ["JsxExpression"]
        // case ts.SyntaxKind.CaseClause: return ["CaseClause"]
        // case ts.SyntaxKind.DefaultClause: return ["DefaultClause"]
        // case ts.SyntaxKind.HeritageClause: return ["HeritageClause"]
        // case ts.SyntaxKind.CatchClause: return ["CatchClause"]
        // case ts.SyntaxKind.PropertyAssignment: return ["PropertyAssignment"]
        // case ts.SyntaxKind.ShorthandPropertyAssignment: return ["ShorthandPropertyAssignment"]
        // case ts.SyntaxKind.SpreadAssignment: return ["SpreadAssignment"]
        // case ts.SyntaxKind.EnumMember: return ["EnumMember"]
        // case ts.SyntaxKind.UnparsedPrologue: return ["UnparsedPrologue"]
        // case ts.SyntaxKind.UnparsedPrepend: return ["UnparsedPrepend"]
        // case ts.SyntaxKind.UnparsedText: return ["UnparsedText"]
        // case ts.SyntaxKind.UnparsedInternalText: return ["UnparsedInternalText"]
        // case ts.SyntaxKind.UnparsedSyntheticReference: return ["UnparsedSyntheticReference"]
        // case ts.SyntaxKind.SourceFile: return ["SourceFile"]
        // case ts.SyntaxKind.Bundle: return ["Bundle"]
        // case ts.SyntaxKind.UnparsedSource: return ["UnparsedSource"]
        // case ts.SyntaxKind.InputFiles: return ["InputFiles"]
        // case ts.SyntaxKind.JSDocTypeExpression: return ["JSDocTypeExpression"]
        // case ts.SyntaxKind.JSDocAllType: return ["JSDocAllType"]
        // case ts.SyntaxKind.JSDocUnknownType: return ["JSDocUnknownType"]
        // case ts.SyntaxKind.JSDocNullableType: return ["JSDocNullableType"]
        // case ts.SyntaxKind.JSDocNonNullableType: return ["JSDocNonNullableType"]
        // case ts.SyntaxKind.JSDocOptionalType: return ["JSDocOptionalType"]
        // case ts.SyntaxKind.JSDocFunctionType: return ["JSDocFunctionType"]
        // case ts.SyntaxKind.JSDocVariadicType: return ["JSDocVariadicType"]
        // case ts.SyntaxKind.JSDocNamepathType: return ["JSDocNamepathType"]
        case ts.SyntaxKind.JSDocComment: return ["JSDocComment"]
        // case ts.SyntaxKind.JSDocTypeLiteral: return ["JSDocTypeLiteral"]
        // case ts.SyntaxKind.JSDocSignature: return ["JSDocSignature"]
        // case ts.SyntaxKind.JSDocTag: return ["JSDocTag"]
        // case ts.SyntaxKind.JSDocAugmentsTag: return ["JSDocAugmentsTag"]
        // case ts.SyntaxKind.JSDocAuthorTag: return ["JSDocAuthorTag"]
        // case ts.SyntaxKind.JSDocClassTag: return ["JSDocClassTag"]
        // case ts.SyntaxKind.JSDocCallbackTag: return ["JSDocCallbackTag"]
        // case ts.SyntaxKind.JSDocEnumTag: return ["JSDocEnumTag"]
        // case ts.SyntaxKind.JSDocParameterTag: return ["JSDocParameterTag"]
        // case ts.SyntaxKind.JSDocReturnTag: return ["JSDocReturnTag"]
        // case ts.SyntaxKind.JSDocThisTag: return ["JSDocThisTag"]
        // case ts.SyntaxKind.JSDocTypeTag: return ["JSDocTypeTag"]
        // case ts.SyntaxKind.JSDocTemplateTag: return ["JSDocTemplateTag"]
        // case ts.SyntaxKind.JSDocTypedefTag: return ["JSDocTypedefTag"]
        // case ts.SyntaxKind.JSDocPropertyTag: return ["JSDocPropertyTag"]
        // case ts.SyntaxKind.SyntaxList: return ["SyntaxList"]
        // case ts.SyntaxKind.NotEmittedStatement: return ["NotEmittedStatement"]
        // case ts.SyntaxKind.PartiallyEmittedExpression: return ["PartiallyEmittedExpression"]
        // case ts.SyntaxKind.CommaListExpression: return ["CommaListExpression"]
        case ts.SyntaxKind.MergeDeclarationMarker: return ["MergeDeclarationMarker"]
        case ts.SyntaxKind.EndOfDeclarationMarker: return ["EndOfDeclarationMarker"]
        case ts.SyntaxKind.Count: return ["Count"]
        default: return null
    }
}

